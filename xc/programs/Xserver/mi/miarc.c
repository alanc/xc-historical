/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/* $XConsortium: miarc.c,v 1.51 88/09/02 16:36:06 matt Exp $ */
/* Author: Keith Packard */
#include "X.h"
#include "Xprotostr.h"
#include "misc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mifpoly.h"
#include "mi.h"

extern double sqrt(), cos(), sin(), atan();

/* these are from our <math.h>, but I'm told some systems don't have
 * math.h and that they're not in all versions of math.h.  Psi! */
#define M_PI	3.14159265358979323846
#define M_PI_2	1.57079632679489661923
#ifndef X_AXIS
# define X_AXIS 0
# define Y_AXIS 1
#endif X_AXIS

/* 360 degrees * 64 sub-degree positions */
#define FULLCIRCLE (64 * 360)

/* This contains the information needed to draw one arc of a polyarc.
 * An array of them can be allocated if the polyarc has more than 1 part */
typedef struct
{
    int		cpt;
    SppPointPtr	pPts;
} POLYARCINFO;

/* ARCDASH - an individual dash, part of a set of arcs */
typedef struct _miArcDash {
    xArc        arc;		/* for miArcSegment - XXX */
} miArcDashRec, *miArcDashPtr;

/* ARCJOIN - an individual join, part of a set of arcs */
typedef struct _miArcJoin {
    SppPointRec juncture;	/* central point where they collide */
    /* points travelling back into each arc away from the open join */
    SppPointRec prev[2];
} miArcJoinRec, *miArcJoinPtr;

/* ARCCAP  - an individual join, part of a set of arcs */
typedef struct _miArcCap {
    SppPointRec juncture;	/* central point where it touches the arc */
    /* point travelling back into the arc away from the desired cap */
    SppPointRec prev;
} miArcCapRec, *miArcCapPtr;

/* This is an entire sequence of arcs, computed and categorized according *
 *  to operation.  The interpreting code better be damn fast!             *
 * Need one of these for even and one for odd stuff.                      */
typedef struct _miDashedArc {
    int          ndashes, njoins, ncaps; /* number of each thingie */
    miArcDashPtr dashes;	/* array of the dashes of this type */
    miArcJoinPtr joins;		/* array of the joins  of this type */
    miArcCapPtr  caps;		/* array of the caps   of this type */
} miDashedArcRec, *miDashedArcPtr;

static miDashedArcPtr miDashArcs();    

#define GCValsFunction		0
#define GCValsForeground 	1
#define GCValsBackground 	2
#define GCValsLineWidth 	3
#define GCValsCapStyle 		4
#define GCValsJoinStyle		5
#define GCValsMask		(GCFunction | GCForeground | GCBackground | \
				 GCLineWidth | GCCapStyle | GCJoinStyle)
static CARD32 gcvals[]= {GXcopy, 1, 0, 0, 0, 0};

#ifdef NOTDEF
/* MIINTERPARC - generate another point past the end of an arc.  This
 *  point is not really part of the arc, but its connection with the
 *  previous point has an exact slope.
 * Calculus voodoo magic...hold on to your chickens!
 * Determine the slope at each of the endpoints using partial
 *  differentiation.  (remember?)  The endpoint slopes must be exact
 *  or the resulting butt faces will have utterly bogus slopes.
 * The resultant point is generated by rotating backwards AWAY from a2.
 */
static void
#ifndef COMPUTEXANDY		/* passed */
miInterpArc( tarc, a1, a2, ppt, x, y )
#else				/* not passed */
miInterpArc( tarc, a1, a2, ppt )
#endif
    xArc        tarc;		/* promise not to look at angles in arc! */
    int         a1, a2;		/* the angles i can look at */
    SppPointPtr ppt;		/* the result is put here */
#ifndef COMPUTEXANDY
    double      x, y;
#endif
{
    double dx, dy, hyp;
#ifdef COMPUTEXANDY		/* not arguments */
    double x, y;
#endif

#ifdef COMPUTEXANDY		/* not arguments */
    x = tarc.x + tarc.width *
	(cos(((double) (-a1) *
	      ((double) M_PI)) / (64 * 180)) + 1.0) / 2.0;
    y = tarc.y + tarc.height *
	(sin(((double) (-a1) *
	      ((double) M_PI)) / (64 * 180)) + 1.0) / 2.0;
#endif
    dx = x - (tarc.x + tarc.width/2.0);
    dy = y - (tarc.y + tarc.height/2.0);
    /* x and y are really the drawable coordinates of the start. *
     * dx is (x - xc), where xc is the center point of the ellipse.  *
     * ditto for dy.                                                     */
    if (ISZERO(dy))		/* infinite slope */
    {
	ppt->x = x;
	ppt->y = y +
	    ((((a1 <= 90*64 || a1 >= 270*64) &&
	       (a2 >= 0)) ||
	      ((a1 >= 90*64 && a1 <= 270*64) &&
	       (a2 <= 0))) ?
	     (1.0) : (-1.0));
    } else {		/* managable slope */
	hyp = ((a1 <= 180*64) ?
	       (a2 >= 0) : (a2 <= 0)) ?
		   (1.0) : (-1.0);
	ppt->x = x + hyp;
	ppt->y = y -
	    ((hyp >= 0.0) ?
	     (dx * tarc.height * tarc.height) :
	     (-dx * tarc.height * tarc.height)) /
		 (dy * tarc.width * tarc.width);
    }
}
#endif

/* MIARCSEGMENT -- private arc helper.                                      *
 *                                                                          *
 * draw one segment of the arc using the arc spans generation routines      *
 */

static void
miArcSegment(pDraw, pGC, tarc)
    DrawablePtr   pDraw;
    GCPtr         pGC;
    xArc          tarc;
{
    int l = pGC->lineWidth;
    int	w, h;
    int a0, a1, startAngle, endAngle;

    /* random (necessary) paranoia checks.  specialized routines could be *
     * written for each of these cases, but who has the time?             */
    if (l < 1)
	l = 1;		/* for 0-width arcs */
    if (tarc.width == 0)
	tarc.width = 1;
    if (tarc.height == 0)
	tarc.height = 1;
    
    a0 = tarc.angle1;
    a1 = tarc.angle2;
    if (a1 == 0)
    	return;
    if (a1 > FULLCIRCLE)
	a1 = FULLCIRCLE;
    else if (a1 < -FULLCIRCLE)
	a1 = -FULLCIRCLE;
    if (a1 < 0) {
    	startAngle = a0 + a1;
	endAngle = a0;
    } else {
	startAngle = a0;
	endAngle = a0 + a1;
    }
    /*
     * bounds check the two angles
     */
    if (startAngle < 0)
	startAngle = FULLCIRCLE - (-startAngle) % FULLCIRCLE;
    if (startAngle >= FULLCIRCLE)
	startAngle = startAngle % FULLCIRCLE;
    if (endAngle < 0)
	endAngle = FULLCIRCLE - (-endAngle) % FULLCIRCLE;
    if (endAngle > FULLCIRCLE)
	endAngle = (endAngle-1) % FULLCIRCLE + 1;
    if (startAngle == endAngle) {
	startAngle = 0;
	endAngle = FULLCIRCLE;
    }
    drawArc ((int) tarc.x, (int) tarc.y,
             (int) tarc.width, (int) tarc.height, l, startAngle, endAngle);
}

/* MIPOLYARC -- Public entry for the polyarc call.
 * Strategy: Similar in many ways to that for wide lines.
 * In general, we will each arc segment as a polyline. (We can make the arc
 * arbitrarily smooth by increasing the number of segments and shortening
 * the length of each segment.)
 * If there's only 1 arc, or if the arc is draw with zero width lines, we 
 * don't have to worry about the rasterop or join styles.   
 * Otherwise, we set up pDrawTo and pGCTo according to the rasterop, then
 * draw using pGCTo and pDrawTo.  If the raster-op was "tricky," that is,
 * if it involves the destination, then we use PushPixels to move the bits
 * from the scratch drawable to pDraw. (See the wide line code for a
 * fuller explanation of this.)
 */
void
miPolyArc(pDraw, pGC, narcs, parcs)
    DrawablePtr	pDraw;
    GCPtr	pGC;
    int		narcs;
    xArc	*parcs;
{
    register int		i;
    double			xMin, xMax, yMin, yMax, yOrg, xOrg, dx, dy;
    int				ifirst, count, width;
    Bool			fTricky;
    DrawablePtr			pDrawTo;
    GCPtr			pGCTo;
    register POLYARCINFO	*polyarcs;

    for(i = 0; i < narcs; i++)
	miArcSegment( pDraw, pGC, parcs[i] );
    fillSpans (pDraw, pGC);
#ifdef NOTDEF
    width = pGC->lineWidth;
    if(width == 0 || narcs == 1)
    {
	if (pGC->lineStyle != LineSolid)
	{
	    int            iphase;
	    miDashedArcPtr dashes;

	    if (!(dashes = miDashArcs(parcs, narcs,
				      pGC->dash, pGC->numInDashList,
				      pGC->dashOffset,
				      (pGC->lineStyle == LineDoubleDash))))
		return;
	    for (iphase = 0; iphase <
		 ((pGC->lineStyle == LineDoubleDash) ? 2 : 1); iphase++)
	    {
		for (i = 0; i < dashes[iphase].ndashes; i++)
		{
		    miArcSegment(pDraw, pGC, dashes[iphase].dashes[i].arc,
				 TRUE, dashes[iphase].dashes[i].pts,
				 dashes[iphase].dashes[i].npts);
		}
		Xfree((pointer) dashes[iphase].dashes);
	    }
	    Xfree((pointer) dashes);
	} else {
	}
    }
    else 
    {
	polyarcs = (POLYARCINFO *)ALLOCATE_LOCAL(narcs * sizeof(POLYARCINFO));
	if(!polyarcs)
	    return;

	xMin = yMin = MAXSHORT;
	xMax = yMax = MINSHORT;

	/* Get all points for all the arcs. */
	for(i = 0; i < narcs; i++)
	{
	    pPts = (SppPointPtr) NULL;
	    cpt = miGetArcPts(&parcs[i], 0, &pPts);
	    polyarcs[i].cpt = cpt;
	    polyarcs[i].pPts = pPts;
	    for(ppt = pPts, count = cpt; --count >= 0; ppt++)
	    {
		xMin = min(xMin, ppt->x);
		yMin = min(yMin, ppt->y);
		xMax = max(xMax, ppt->x);
		yMax = max(yMax, ppt->y);
	    }
	}
	/* Set up pDrawTo and pGCTo based on the rasterop */
	switch(pGC->alu)
	{
	  case GXclear:		/* 0 */
	  case GXcopy:		/* src */
	  case GXcopyInverted:	/* NOT src */
	  case GXset:		/* 1 */
	    fTricky = FALSE;
	    pDrawTo = pDraw;
	    pGCTo = pGC;
	    break;
	  default:
	    fTricky = TRUE;

	    pGCTo = GetScratchGC(1, pDraw->pScreen);
	    gcvals[GCValsLineWidth] = pGC->lineWidth;
	    gcvals[GCValsCapStyle] = pGC->capStyle;
	    gcvals[GCValsJoinStyle] = pGC->joinStyle;
	    DoChangeGC(pGCTo, GCValsMask, gcvals, 0);
    
    	    xOrg = xMin - ((double) width + 1)/2;
	    yOrg = yMin - ((double) width + 1)/2;
	    dx = xMax - xMin + ((double) width) + 1;
	    dy = yMax - yMin + ((double) width) + 1;
	    for(i = 0; i < narcs; i++)
	    {
		for(ppt = polyarcs[i].pPts, count = polyarcs[i].cpt;
		    --count >= 0;
		    ppt++)
		{
		    ppt->x -= xOrg;
		    ppt->y -= yOrg;
		}
	    }
	    if (pGC->miTranslate && (pDraw->type == DRAWABLE_WINDOW))
	    {
		xOrg += (double) ((WindowPtr)pDraw)->absCorner.x;
		yOrg += (double) ((WindowPtr)pDraw)->absCorner.y;
	    }

	    /* allocate a 1 bit deep pixmap of the appropriate size, and
	     * validate it */
	    pDrawTo = (DrawablePtr)(*pDraw->pScreen->CreatePixmap)
					(pDraw->pScreen, dx, dy, 1, XYBitmap);
	    ValidateGC(pDrawTo, pGCTo);
	    miClearDrawable(pDrawTo, pGCTo);
	}

	ifirst = 0;

	if (polyarcs[0].cpt) {
	    SppPointRec pt0, ptn;

	    for (i = narcs - 1;
		 (i >= 0) && (cpt = polyarcs[i].cpt);
		 ifirst = i, i--) {
		pt0 = polyarcs[ifirst].pPts[0],
		ptn = polyarcs[i].pPts[cpt - 1];
		
		if (PTUNEQUAL(pt0, ptn))
		    break;
	    }
	}
	
	cptAll = 0;
	pAllPts = (SppPointPtr) NULL;

	for(i = ifirst, count = narcs; --count >= 0; i++)
	{
	    if (i == narcs)
		i = 0;	/* wrap */

	    cpt = polyarcs[i].cpt;
	    pPts = polyarcs[i].pPts;

	    if((cpt > 0) && (cptAll > 0) &&
	       PTISEQUAL(pPts[0], pAllPts[cptAll-1]))
	    {			/* join between arcs here - XXX */
		cpt--;
		if (!(pAllPts = (SppPointPtr)
		      Xrealloc((pointer)pAllPts,
			       (cptAll + cpt) * sizeof(SppPointRec))))
		    return;
		bcopy((char *)&pPts[1],
		      (char *)&pAllPts[cptAll], 
		      cpt * sizeof(SppPointRec));
		Xfree((pointer)pPts);
		cptAll += cpt;
	    }
	    else
	    {			/* this arc does not join to any other arc */
		/* Flush what we have so far and start collecting again */
		if(cptAll > 0)
		{
		    (*pGCTo->LineHelper) (pDrawTo, pGCTo,
					  !(pGC->lineStyle == LineDoubleDash),
					  cptAll, pAllPts, 0, 0);
		    Xfree((pointer)pAllPts);
		    if(fTricky)
		    {
		        (*pGC->PushPixels)(pGC, pDrawTo, pDraw, (int) dx,
					   (int) dy, (int) xOrg, (int) yOrg);
		        miClearDrawable((DrawablePtr)pDrawTo, pGCTo);
		    }
		}
		cptAll = cpt;
		pAllPts = pPts;
	    }
	}

	if (cptAll > 0)
	{			/* this may be two joined arcs or one arc */
	    (*pGCTo->LineHelper) (pDrawTo, pGCTo,
				  !(pGC->lineStyle == LineDoubleDash),
				  cptAll, pAllPts, 0, 0);
	    Xfree((pointer)pAllPts);
	    if(fTricky)
		(*pGC->PushPixels)(pGC, pDrawTo, pDraw, (int) dx, (int) dy,
				   (int) xOrg, (int) yOrg);
	}
	if(fTricky)
	{
	    (*pGCTo->pScreen->DestroyPixmap)((PixmapPtr)pDrawTo);
	    FreeScratchGC(pGCTo);
	}
	DEALLOCATE_LOCAL(polyarcs);
    }
#endif
}

/* MIPOLYFILLARC -- The public entry for the PolyFillArc request.
 * Since we don't have to worry about overlapping segments, we can just
 * fill each arc as it comes.  As above, we convert the arc into a set of
 * line segments and then fill the resulting polygon.
 */
void
miPolyFillArc(pDraw, pGC, narcs, parcs)
    DrawablePtr	pDraw;
    GCPtr	pGC;
    int		narcs;
    xArc	*parcs;
{
    int	i, cpt;
    SppPointPtr pPts;

    for(i = 0; i < narcs; i++)
    {
	/* We do this test every time because a full circle PieSlice isn't
	 * really a slice, but a full pie, and the Chord code (below) should
	 * handle it better */
        if(pGC->arcMode == ArcPieSlice && parcs[i].angle2 < FULLCIRCLE)
	{
	    if (!(pPts = (SppPointPtr)Xalloc(sizeof(SppPointRec))))
		return;
	    if(cpt = miGetArcPts(&parcs[i], 1, &pPts))
	    {
		pPts[0].x = (double) (parcs[i].x +
				      ((double) parcs[i].width)/2);
		pPts[0].y = (double) (parcs[i].y +
				      ((double) parcs[i].height)/2);
		miFillSppPoly(pDraw, pGC, cpt + 1, pPts, 0, 0);
		Xfree((pointer) pPts);
	    }
	}
        else /* Chord */
	{
	    pPts = (SppPointPtr)NULL;
	    if(cpt = miGetArcPts(&parcs[i], 0, &pPts))
	    {
		miFillSppPoly(pDraw, pGC, cpt, pPts, 0, 0);
		Xfree((pointer) pPts);
	    }
	}
    }
}

#define REALLOC_STEP 10		/* how often to realloc */
/* MIGETARCPTS -- Converts an arc into a set of line segments -- a helper
 * routine for arc and line (round cap) code.
 * Returns the number of points in the arc.  Note that it takes a pointer
 * to a pointer to where it should put the points and an index (cpt).
 * This procedure allocates the space necessary to fit the arc points.
 * Sometimes it's convenient for those points to be at the end of an existing
 * array. (For example, if we want to leave a spare point to make sectors
 * instead of segments.)  So we pass in the Xalloc()ed chunk that contains the
 * array and an index saying where we should start stashing the points.
 * If there isn't an array already, we just pass in a null pointer and 
 * count on Xrealloc() to handle the null pointer correctly.
 */
int
miGetArcPts(parc, cpt, ppPts)
    xArc	*parc;	/* points to an arc */
    int		cpt;	/* number of points already in arc list */
    SppPointPtr	*ppPts; /* pointer to pointer to arc-list -- modified */
{
    double 	st,	/* Start Theta, start angle */
                et,	/* End Theta, offset from start theta */
		dt,	/* Delta Theta, angle to sweep ellipse */
		cdt,	/* Cos Delta Theta, actually 2 cos(dt) */
    		x0, y0,	/* the recurrence formula needs two points to start */
		x1, y1,
		x2, y2, /* this will be the new point generated */
		xc, yc, /* the center point */
                xt, yt;	/* possible next point */
    int		count, i, axis, npts = 2; /* # points used thus far */
    double      asin();
    SppPointPtr	poly;
    DDXPointRec last;		/* last point on integer boundaries */

    /* The spec says that positive angles indicate counterclockwise motion.
     * Given our coordinate system (with 0,0 in the upper left corner), 
     * the screen appears flipped in Y.  The easiest fix is to negate the
     * angles given */
    
    /* Throw out multiples of 360 degrees. */
    i = -parc->angle1;
    if(i < 0)
    {
	while (i < -FULLCIRCLE)
	    i += FULLCIRCLE;
    }
    else
    {
	while(i > FULLCIRCLE)
	    i -= FULLCIRCLE;
    }
    st = (double ) i;
    st *= ((double)M_PI) / (64 * 180); 	/* convert to degrees, then to rads */

    i = -parc->angle2;
    /* If it's more than one full rotation, make it exactly 1 rotation */
    if (i > FULLCIRCLE)
	i = FULLCIRCLE;
    if (i < -FULLCIRCLE)
	i = -FULLCIRCLE;
    et = (double) i;
    et *= ((double)M_PI) / (64 * 180); 	/* convert to degrees, then to rads */

    /* Try to get a delta theta that is within 1/2 pixel.  Then adjust it
     * so that it divides evenly into the total.
     * I'm just using cdt 'cause I'm lazy.
     */
    cdt = max(parc->width, parc->height)/2.0;
    if(cdt <= 0)
	return 0;
    dt = asin( ((double) 1) / cdt ); /* minimum step necessary */
    count = et/dt;
    count = abs(count) + 1;
    dt = et/count;	
    count++;

    cdt = 2 * cos(dt);
#ifdef NOARCCOMPRESSION
    if (!(poly = (SppPointPtr) Xrealloc((pointer)*ppPts,
					(cpt + count) * sizeof(SppPointRec))))
	return(0);
    *ppPts = poly;
#else				/* ARCCOMPRESSION */
    if (!(poly = (SppPointPtr) Xrealloc((pointer)*ppPts,
					(cpt + 2) * sizeof(SppPointRec))))
	return(0);
#endif				/* ARCCOMPRESSION */

    xc = parc->width/2.0;		/* store half width and half height */
    yc = parc->height/2.0;
    axis = (xc >= yc) ? X_AXIS : Y_AXIS;
    
    x0 = xc * cos(st);
    y0 = yc * sin(st);
    x1 = xc * cos(st + dt);
    y1 = yc * sin(st + dt);
    xc += parc->x;		/* by adding initial point, these become */
    yc += parc->y;		/* the center point */

    poly[cpt].x = (xc + x0);
    poly[cpt].y = (yc + y0);
    last.x = ROUNDTOINT( poly[cpt + 1].x = (xc + x1) );
    last.y = ROUNDTOINT( poly[cpt + 1].y = (yc + y1) );

    for(i = 2; i < count; i++)
    {
	x2 = cdt * x1 - x0;
	y2 = cdt * y1 - y0;

#ifdef NOARCCOMPRESSION
 	poly[cpt + i].x = (xc + x2);
 	poly[cpt + i].y = (yc + y2);
#else				/* ARCCOMPRESSION */
	xt = xc + x2;
	yt = yc + y2;
 	if (((axis == X_AXIS) ?
	     (ROUNDTOINT(yt) != last.y) :
	     (ROUNDTOINT(xt) != last.x)) ||
	    i > count - 3)	/* insure 2 at the end */
 	{
	    /* allocate more space if we are about to need it */
	    /* include 1 extra in case minor axis swaps */
 	    if ((npts - 2) % REALLOC_STEP == 0)
	    {
 		if (!(poly = (SppPointPtr)
		      Xrealloc((pointer) poly,
			       ((npts + REALLOC_STEP + cpt) *
				sizeof(SppPointRec)))))
		    return(0);
	    }
	    /* check if we just switched direction in the minor axis */
	    if (((poly[cpt + npts - 2].y - poly[cpt + npts - 1].y > 0.0) ?
		 (yt - poly[cpt + npts - 1].y > 0.0) :
		 (poly[cpt + npts - 1].y - yt > 0.0)) ||
		((poly[cpt + npts - 2].x - poly[cpt + npts - 1].x > 0.0) ?
		 (xt - poly[cpt + npts - 1].x > 0.0) :
		 (poly[cpt + npts - 1].x - xt > 0.0)))
	    {
		/* Since the minor axis direction just switched, the final *
		 * point before the change must be included, or the        *
		 * following segment will begin before the minor swap.     */
		poly[cpt + npts].x = xc + x1;
		poly[cpt + npts].y = yc + y1;
		npts++;
		if ((npts - 2) % REALLOC_STEP == 0)
		{
		    if (!(poly = (SppPointPtr)
			  Xrealloc((pointer) poly,
				   ((npts + REALLOC_STEP + cpt) *
				    sizeof(SppPointRec)))))
			return(0);
		}
	    }
 	    last.x = ROUNDTOINT( poly[cpt + npts].x = xt );
 	    last.y = ROUNDTOINT( poly[cpt + npts].y = yt );
 	    npts++;
 	}
#endif				/* ARCCOMPRESSION */

	x0 = x1; y0 = y1;
	x1 = x2; y1 = y2;
    }
#ifndef NOARCCOMPRESSION	/* i.e.:  ARCCOMPRESSION */
    count = i = npts;
#endif				/* ARCCOMPRESSION */
    /* adjust the last point */
    if (abs(parc->angle2) >= FULLCIRCLE)
	poly[cpt +i -1] = poly[0];
    else {
	poly[cpt +i -1].x = (cos(st + et) * parc->width/2.0 + xc);
	poly[cpt +i -1].y = (sin(st + et) * parc->height/2.0 + yc);
    }

#ifndef NOARCCOMPRESSION	/* i.e.:  ARCCOMPRESSION */
    *ppPts = poly;		/* may have changed during reallocs */
#endif				/* ARCCOMPRESSION */
    return(count);
}

#ifdef NOTDEF

/* MIDASHARCS -- Converts a list of arcs to a list of dashed arcs.            *
 * Each dashed arc is represented as a record with the number of sub-arcs in  *
 *  the entire dashed arc, and then an array of all the sub-arcs.  Each sub-  *
 *  arc consists of arc segments with assigned phase and a list of double-    *
 *  precision points.                                                         *
 * This routine can parse an entire list of arcs as passed to PolyArc, since  *
 *  it checks for point connection before applying the dash offset.  That is, *
 *  if the next arc begins where the last one ends, then the current offset   *
 *  is retained, otherwise the current offset and dash phase is recomputed    *
 *  based on the passed offset.                                               *
 * The passed pointer of arc-dashes should actually be an array of the same   *
 *  size as the array of argument arcs.  It will be filled in by the routine. *
 *  The number of arcs filled in will be returned.  It should be equal to the *
 *  number of arcs passed.                                                    *
 */
/* Either returns a pointer to the even dashes or an array of the even and *
 * then the odd dashed arcs.                                               */
static miDashedArcPtr
miDashArcs(pArc, nArcs, pDash, nDashes, dashOffset, isDoubleDash)
    xArc	  *pArc;	/* array of arcs to dash */
    int		  nArcs;	/* number of arcs in passed arc array */
    unsigned char *pDash;
    int           nDashes;
    int           dashOffset;	/* for dashes -- from gc */
    Bool          isDoubleDash;	/* TRUE if double dashed, otherwise onoff */
{
    double 	 st,	/* Start Theta, start angle */
                 et,	/* End Theta, offset from start theta */
		 dt,	/* Delta Theta, angle to sweep ellipse */
		 cdt,	/* Cos Delta Theta, actually 2 cos(dt) */
    		 x0, y0, /* the recurrence formula needs two points to start */
		 x1, y1,
		 x2, y2, /* this will be the new point generated */
		 xc, yc, /* the center point */
                 xt, yt;	/* possible next point */
    int		 count, i, istart, axis;
    double       asin();
    SppPointPtr	 poly;
    SppPointRec  lastPt;
    DDXPointRec  last;		/* last point on integer boundaries */
    int          lenCur;	/* used part of current dash */
    int          lenMax;	/* the desired length of this dash */
    int          iDash = 0;	/* index of current dash segment */
    int          nSegs = 0;	/* number of segments filled in */
    miDashedArcPtr pDashed;
    int          which;		/* EVEN_DASH or ODD_DASH */
    int          iphase;	/* 0 = even, 1 = odd */
    int          npts,		/* number of points used so far */
                 nalloced;	/* number of points allocated so far */
    int          a1;		/* angle1 for this arc */

    if (!(pDashed = (miDashedArcPtr) Xalloc((isDoubleDash ? 2 : 1) *
					    sizeof(miDashedArcRec))))
	return( NULL );		/* hosed */

    for ( ; nArcs > 0; nArcs--, pArc++, nSegs++)
    {
    	/* Throw out multiples of 360 degrees. */
	if (pArc->angle2 > FULLCIRCLE)
	    pArc->angle2 = FULLCIRCLE;
	else if (pArc->angle2 < -FULLCIRCLE)
	    pArc->angle2 = -FULLCIRCLE;

	/* The spec says that positive angles indicate counterclockwise motion.
	 * Given our coordinate system (with 0,0 in the upper left corner), 
	 * the screen appears flipped in Y.  The easiest fix is to negate the
	 * angles given */
	i = - (a1 = pArc->angle1);

	if(i < 0)
	{
	    while (i < -FULLCIRCLE)
		i += FULLCIRCLE;
	}
	else
	{
	    while(i > FULLCIRCLE)
		i -= FULLCIRCLE;
	}
	st = (double ) i;
	st *= ((double)M_PI) / (64 * 180); /* to degrees, then to rads */
	
	i = -pArc->angle2;
	/* If it's more than one full rotation, make it exactly 1 rotation */
	/* hey...it already is! */
	et = (double) i;
	et *= ((double)M_PI) / (64 * 180); /* to degrees, then to rads */
	
	/* Try to get a delta theta that is within 1/2 pixel.  Then adjust it
	 * so that it divides evenly into the total.
	 * I'm just using cdt 'cause I'm lazy.
	 */
	cdt = max(pArc->width, pArc->height)/2.0;
	if(cdt <= 0)
	    return 0;
	dt = asin( ((double) 1) / cdt ); /* minimum step necessary */
	count = et/dt;
	count = abs(count) + 1;
	dt = et/count;	
	count++;
	
	cdt = 2 * cos(dt);
	/* note this insists on arc compression */
	poly = (SppPointPtr) Xalloc((1+(nalloced = 3)) *
				    sizeof(SppPointRec));
	
	xc = pArc->width/2.0;		/* store half width and half height */
	yc = pArc->height/2.0;
	axis = (xc >= yc) ? X_AXIS : Y_AXIS;
	
	x0 = xc * cos(st);
	y0 = yc * sin(st);
	x1 = xc * cos(st + dt);
	y1 = yc * sin(st + dt);
	xc += pArc->x;		/* by adding initial point, these become */
	yc += pArc->y;		/* the center point */
	
	poly[1].x = (xc + x0);
	poly[1].y = (yc + y0);
	last.x = ROUNDTOINT( poly[2].x = (xc + x1) );
	last.y = ROUNDTOINT( poly[2].y = (yc + y1) );
	npts = 3;		/* got 2 pts so far */
	
	/* Handle dash offset if necessary.  May be retained from before. */
	if (nSegs > 0)
	{			/* we've already generated at least 1 arc */
	    if (ROUNDTOINT(xt) !=
		ROUNDTOINT(poly[1].x) ||
		ROUNDTOINT(yt) !=
		ROUNDTOINT(poly[1].y))
	    {			/* get next dash position */
		lenCur = dashOffset;
		which = EVEN_DASH;
		while (lenCur > pDash[iDash])
		{
		    lenCur -= pDash[iDash];
		    iDash++;
		    if (iDash >= nDashes)
			iDash = 0;
		    which = ~which;
		}
		lenMax = pDash[iDash];
	    }			/* otherwise retain old dash position */
	} else {		/* first segment, so restart dashes */
	    lenCur = dashOffset;
	    which = EVEN_DASH;
	    while (lenCur > pDash[iDash])
	    {
		lenCur -= pDash[iDash];
		iDash++;
		if (iDash >= nDashes)
		    iDash = 0;
		which = ~which;
	    }
	    lenMax = pDash[iDash];
	}			/* now dashes are set to correct offset */
	
	for (iphase = 0; iphase < (isDoubleDash ? 2 : 1); iphase++)
	{
	    pDashed[iphase].ndashes = pDashed[iphase].njoins =
		pDashed[iphase].ncaps = 0;
	    pDashed[iphase].dashes = (miArcDashPtr) NULL;
	    pDashed[iphase].joins  = (miArcJoinPtr) NULL;
	    pDashed[iphase].caps   = (miArcCapPtr)  NULL;
	}
	lenCur++;		/* cause we a'ready did x1, y1..right? */
	
	for(istart = 0, i = 2; i < count; i++)
	{
	    x2 = cdt * x1 - x0;
	    y2 = cdt * y1 - y0;
	    
	    lenCur++;
	    if (lenCur >= lenMax) /* phase slip here like in line code? XXX */
	    {
		lastPt = poly[npts - 1];
		if (which == EVEN_DASH)
		    iphase = 0;
	        else if (isDoubleDash)
		    iphase = 1;
		else		/* odd_dash but style = on-off-dashed */
		{
		    iphase = 2;
		    Xfree((pointer) poly); /* XXX dont generate this!! */
		}
		if (iphase < 2)
		{
		    if ((pDashed[iphase].ndashes) % REALLOC_STEP == 0)
			pDashed[iphase].dashes = (miArcDashPtr)
			    Xrealloc((pointer) pDashed[iphase].dashes,
				     (pDashed[iphase].ndashes+REALLOC_STEP) *
				     sizeof(miArcDashRec));
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc =
			*pArc;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc.angle2
			= a1 - dt * i * 180 * 64 / M_PI -
			    pArc->angle1;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].pts = poly;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].npts =
			npts;
		    pDashed[iphase].ndashes++;
		}
		pArc->angle1 = a1 -
		    dt * 180 * 64 * i / M_PI; /* XXX - ack! */
		npts = 2;
		/* next segment starts where this one ended */
		if (!(poly = (SppPointPtr)
		      Xalloc(((1+(nalloced = 1 + REALLOC_STEP)) *
			      sizeof(SppPointRec)))))
		    return ( NULL );
		poly[1] = lastPt;
		istart = i;	/* for next arc segment collection */
		which = ~which;
		iDash++;
		if (iDash >= nDashes)
		    iDash = 0;
		lenMax = pDash[iDash];
		lenCur = 0;
	    }
	    
	    xt = xc + x2;
	    yt = yc + y2;
	    if (((axis == X_AXIS) ?
		 (ROUNDTOINT(yt) != last.y) :
		 (ROUNDTOINT(xt) != last.x)) ||
		i > count - 3)	/* insure 2 at the end */
	    {
		/* allocate more space if we are about to need it */
		if (npts >= nalloced)
		    poly = (SppPointPtr)
			Xrealloc((pointer) poly,
				 ((1+(nalloced = npts + REALLOC_STEP)) *
				  sizeof(SppPointRec)));
		/* check if we just switched direction in the minor axis */
		if (npts >= 3)
		{
		    if (((poly[npts - 2].y - poly[npts - 1].y > 0.0) ?
			 (yt - poly[npts - 1].y > 0.0) :
			 (poly[npts - 1].y - yt > 0.0)) ||
			((poly[npts - 2].x - poly[npts - 1].x > 0.0) ?
			 (xt - poly[npts - 1].x > 0.0) :
			 (poly[npts - 1].x - xt > 0.0)))
		    {		/* axis swap (explained in miGetArcPts) */
			poly[npts].x = xc + x1;
			poly[npts].y = yc + y1;
			npts++;
			if (npts >= nalloced)
			    poly = (SppPointPtr)
				Xrealloc((pointer) poly,
					 ((1+(nalloced = npts + REALLOC_STEP))
					  *sizeof(SppPointRec)));
		    }
		}
		last.x = ROUNDTOINT( poly[npts].x = xt );
		last.y = ROUNDTOINT( poly[npts].y = yt );
		npts++;
	    }
	    
	    x0 = x1; y0 = y1;
	    x1 = x2; y1 = y2;
	}
	count = i = npts;
	/* adjust the last point */
	if (abs(pArc->angle2) >= FULLCIRCLE)
	    poly[i-1] = poly[1];
	else {
	    poly[i-1].x = (cos(st + et) * pArc->width/2.0 + xc);
	    poly[i-1].y = (sin(st + et) * pArc->height/2.0 + yc);
	}

	/* put points generated for this arc into this dash segment */
	if (which == EVEN_DASH)
	    iphase = 0;
	else if (isDoubleDash)
	    iphase = 1;
	else		/* odd_dash but style = on-off-dashed */
	{
	    iphase = 2;
	    Xfree((pointer) poly);
	}
	if (iphase < 2)
	{
	    if ((pDashed[iphase].ndashes) % REALLOC_STEP == 0)
		pDashed[iphase].dashes = (miArcDashPtr)
		    Xrealloc((pointer) pDashed[iphase].dashes,
			     (pDashed[iphase].ndashes+REALLOC_STEP) *
			     sizeof(miArcDashRec));
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc =
		*pArc;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc.angle2
		= a1 + pArc->angle2 - pArc->angle1;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].pts = poly;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].npts =
		npts;
	    pDashed[iphase].ndashes++;
	}
    }
    
    return( pDashed );
}
#endif

/*
 * scan convert wide arcs.
 */

#undef fabs
#undef min
#undef max

extern double	ceil (), floor (), fabs (), sin (), cos (), sqrt (), pow ();

#ifndef PI
# define PI (3.1415926535897932384626434)
#endif

# define Dsin(d)	((d) == 0.0 ? 0.0 : ((d) == 90.0 ? 1.0 : sin(d*PI/180.0)))
# define Dcos(d)	((d) == 0.0 ? 1.0 : ((d) == 90.0 ? 0.0 : cos(d*PI/180.0)))

# define NEWTON_LIMIT	(0.0000001)

struct bound {
	double	min, max;
};

struct line {
	double	m, b;
	int	valid;
};

/*
 * these are all y value bounds
 */

struct arc_bound {
	struct bound	elipse;
	struct bound	inner;
	struct bound	outer;
	struct bound	left;
	struct bound	right;
};

struct accelerators {
	double		tail_y;
	double		h2;
	double		w2;
	double		h4;
	double		w4;
	double		h2mw2;
	double		wh2mw2;
	double		wh4;
	struct line	left, right;
};

struct arc_def {
	double	w, h, l;
	double	a0, a1;
};

double
Sqrt (x)
double	x;
{
	if (x < 0) {
		if (x > -NEWTON_LIMIT)
			return 0;
		else
			abort ();
	}
	return sqrt (x);
}

double
fmax (a, b)
double	a,b;
{
	return a > b? a : b;
}

double
fmin (a, b)
double	a, b;
{
	return a < b ? a : b;
}

boundedLt (value, bounds)
double	value;
struct bound	bounds;
{
	return bounds.min <= value && value < bounds.max;
}

boundedLe (value, bounds)
double	value;
struct bound	bounds;
{
	return bounds.min <= value && value <= bounds.max;
}

/*
 * this computes the elipse y value associated with the
 * bottom of the tail.
 */

# define CUBED_ROOT_2	1.2599210498948732038115849718451499938964
# define CUBED_ROOT_4	1.5874010519681993173435330390930175781250

double
tailElipseY (w, h, l)
	double	w, h, l;
{
	extern double	Sqrt (), pow ();
	double		t;

	if (w != h) {
		t = (pow (h * l * w, 2.0/3.0) - CUBED_ROOT_4 * h*h) /
		    (w*w - h*h);
		if (t < 0)
			return 0;	/* no tail */
		return h / CUBED_ROOT_2 * Sqrt (t);
	} else
		return 0;
}

/*
 * inverse functions -- compute edge coordinates
 * from the elipse
 */

double
outerXfromY (y, def, bound, acc)
	double			y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	x;

	x = def->w * Sqrt ((acc->h2 - (y*y)) / acc->h2);

	return x + (x * acc->h2 * def->l) /
		   (2 * Sqrt (x*x *acc->h4 + y*y * acc->w4));
}

double
outerYfromY (y, def, acc)
	double	y;
	struct arc_def		*def;
	struct accelerators	*acc;
{
	double	x;

	x = def->w * Sqrt ((acc->h2 - (y*y)) / acc->h2);

	return y + (y * acc->w2 * def->l) /
		   (2 * Sqrt (x*x * acc->h4 + y*y * acc->w4));
}

double
innerXfromY (y, def, bound, acc)
	double			y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	x;

	x = def->w * Sqrt ((acc->h2 - (y*y)) / acc->h2);
	
	return x - (x * acc->h2 * def->l) /
		   (2 * Sqrt (x*x * acc->h4 + y*y * acc->w4));
}

double
innerYfromY (y, def, acc)
	double	y;
	struct arc_def		*def;
	struct accelerators	*acc;
{
	double	x;

	x = def->w * Sqrt ((acc->h2 - (y*y)) / acc->h2);

	return y - (y * acc->w2 * def->l) /
		   (2 * Sqrt (x*x * acc->h4 + y*y * acc->w4));
}

computeLine (x1, y1, x2, y2, line)
	double		x1, y1, x2, y2;
	struct line	*line;
{
	if (y1 == y2)
		line->valid = 0;
	else {
		line->m = (x1 - x2) / (y1 - y2);
		line->b = (x1 * (y1-y2) - y1 * (x1 - x2)) / (y1 - y2);
		line->valid = 1;
	}
}

computeAcc (def, acc)
	struct arc_def		*def;
	struct accelerators	*acc;
{
	acc->h2 = def->h * def->h;
	acc->w2 = def->w * def->w;
	acc->h4 = acc->h2 * acc->h2;
	acc->w4 = acc->w2 * acc->w2;
	acc->h2mw2 = acc->h2 - acc->w2;
	acc->wh2mw2 = def->w * acc->h2mw2;
	acc->wh4 = def->w * acc->h4;
	acc->tail_y = tailElipseY (def->w, def->h, def->l);
}

computeBound (def, bound, acc)
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double		t;
	double		innerTaily;
	double		tail_y;

	bound->elipse.min = Dsin (def->a0) * def->h;
	bound->elipse.max = Dsin (def->a1) * def->h;
	bound->outer.min = outerYfromY (bound->elipse.min, def, acc);
	bound->outer.max = outerYfromY (bound->elipse.max, def, acc);
	bound->inner.min = innerYfromY (bound->elipse.min, def, acc);
	bound->inner.max = innerYfromY (bound->elipse.max, def, acc);
	bound->left.min = bound->inner.max;
	bound->left.max = bound->outer.max;
	bound->right.min = bound->inner.min;
	bound->right.max = bound->outer.min;
	if (bound->inner.min > bound->inner.max) {
		t = bound->inner.min;
		bound->inner.min = bound->inner.max;
		bound->inner.max = t;
	}
	tail_y = acc->tail_y;
	if (tail_y > bound->elipse.max)
		tail_y = bound->elipse.max;
	else if (tail_y < bound->elipse.min)
		tail_y = bound->elipse.min;
	innerTaily = innerYfromY (tail_y, def, acc);
	if (bound->inner.min > innerTaily)
		bound->inner.min = innerTaily;
	if (bound->inner.max < innerTaily)
		bound->inner.max = innerTaily;
	/*
	 * compute equations for end lines
	 */
	computeLine (Dcos (def->a0) * def->w, bound->elipse.min,
		      outerXfromY (bound->elipse.min, def, bound, acc),
		      bound->outer.min, &acc->right);
	computeLine (Dcos (def->a1) * def->w, bound->elipse.max,
		      outerXfromY (bound->elipse.max, def, bound, acc),
		      bound->outer.max, &acc->left);
}

/*
 * using newtons method, compute the elipse y value
 * associated with the given edge value (either outer or
 * inner)
 */

double
elipseY (edge_y, def, bound, acc, outer, initialY)
	double			edge_y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
	double			initialY;
{
	double	w, h, l, y, newy, miny;
	double	h2, h4, w2, h2mw2, q, q3o2;
	double	wlh2mw2, wlh4, y2;
	int	count;
	
	/*
	 * compute some accelerators
	 */
	w = def->w;
	h = def->h;
	l = outer ? def->l : -def->l;
	if (!outer) {
		if (bound->inner.min == edge_y && edge_y == 0)
			return 0;
		if (bound->inner.max == edge_y && edge_y == h + l/2)
			return h;
	}
	h2 = acc->h2;
	h4 = acc->h4;
	w2 = acc->w2;
	h2mw2 = acc->h2mw2;
	wlh2mw2 = l * acc->wh2mw2;
	wlh4 = l * acc->wh4;
	/*
	 * collect estimate
	 */
	newy = initialY;

	/*
	 * iterate to solution
	 */

	count = 0;

	do {
		/*                 3/2    3      2   2
		 *        2 edge_y q    + y w l (h - w )
		 * newy = -----------------------------
                 *                   3/2    4
		 *                2 q    + h l w
		 *
		 *            4   2  2   2
		 * where q = h - y (h - w )
		 *
		 * this equation is derived from solving
		 *
		 *                 2 y           w^2 h^2          l
		 *  edge_y = y +/- --- *  --------------------- * -
		 *                 h^2   \| 4x^2 h^4 + 4y^2 w^4   2
		 *
		 *  substituting the solution for x^2 from the elipse:
		 *
		 *   x^2   y^2
		 *   --- + --- = 1
		 *   w^2   h^2
		 *
		 * using newtons method.  Check it out with macsyma.
		 */ 
		y = newy;
		y2 = y*y;
		q = h4 - y2 * h2mw2;
		q3o2 = 2 * Sqrt (q * q * q);

		newy = (edge_y * q3o2 + y2*y * wlh2mw2) / (q3o2 + wlh4);

		if (newy < 0 && outer)
			newy = fmax ((y + newy ) / 2, 0);
		if (newy > h)
			newy = fmin ((y + newy) / 2, h);
		if (++count > 1000)
			return (newy + y) / 2;
	} while (fabs (y - newy) > NEWTON_LIMIT);
	return newy;
}

double
elipseX (elipse_y, def, acc)
	double			elipse_y;
	struct arc_def		*def;
	struct accelerators	*acc;
{
	return def->w / def->h * Sqrt (acc->h2 - elipse_y * elipse_y);
}

double
outerX (outer_y, def, bound, acc)
	double			outer_y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	y, inity;

	if (outer_y == bound->outer.min)
		y = bound->elipse.min;
	if (outer_y == bound->outer.max)
		y = bound->elipse.max;
	else {
		inity = def->h * outer_y / (def->h + def->l/2);
		y = elipseY (outer_y, def, bound, acc, 1, inity);
		if (!boundedLe (y, bound->elipse)) {
			if (def->h < def->w)
				inity = bound->elipse.min;
			else
				inity = bound->elipse.max;
			y = elipseY (outer_y, def, bound, acc, 1, inity);
		}
	}
	return outerXfromY (y, def, bound, acc);
}

double
innerX (inner_y, def, bound, acc)
	double			inner_y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	y, inity, x, xalt;

	if (def->h == def->l/2)
		inity = def->h;
	else
		inity = def->h * inner_y / (def->h - def->l/2);
	if (def->h != def->w) {
 		if (boundedLe (acc->tail_y, bound->elipse)) {
			if (def->h < def->w) {
				if (inity <= acc->tail_y + 2)
					inity = acc->tail_y + 2;
			} else {
				if (inity >= acc->tail_y - 2)
					inity = acc->tail_y - 2;
			}
		}
	}
	y = elipseY (inner_y, def, bound, acc, 0, inity);
	if (!boundedLe (y, bound->elipse)) {
		if (def->h < def->w)
			inity = bound->elipse.min;
		else
			inity = bound->elipse.max;
		y = elipseY (inner_y, def, bound, acc, 0, inity);
	}
	x = innerXfromY (y, def, bound, acc);
	if (acc->left.valid && boundedLe (inner_y, bound->left)) {
		xalt = acc->left.m * inner_y + acc->left.b;
		if (xalt < x)
			x = xalt;
	}
	if (acc->right.valid && boundedLe (inner_y, bound->right)) {
		xalt = acc->right.m * inner_y + acc->right.b;
		if (xalt < x)
			x = xalt;
	}
	return x;
}

/*
 * this section computes the x value of the span at y 
 * intersected with the specified face of the elipse.
 *
 * this is the min/max X value over the set of normal
 * lines to the entire elipse,  the equation of the
 * normal lines is:
 *
 *     elipse_x h^2                   h^2
 * x = ------------ y + elipse_x (1 - --- )
 *     elipse_y w^2                   w^2
 *
 * compute the derivative with-respect-to elipse_y and solve
 * for zero:
 *    
 *       (w^2 - h^2) elipse_y^3 + h^4 y
 * 0 = - ----------------------------------
 *       h w elipse_y^2 sqrt (h^2 - elipse_y^2)
 *
 *            (   h^4 y     )
 * elipse_y = ( ----------  ) ^ (1/3)
 *            ( (h^2 - w^2) )
 *
 * The other two solutions to the equation are imaginary.
 *
 * This gives the position on the elipse which generates
 * the normal with the largest/smallest x intersection point.
 *
 * Now compute the second derivative to check whether
 * the intersection is a minimum or maximum:
 *
 *    h (y0^3 (w^2 - h^2) + h^2 y (3y0^2 - 2h^2))
 * -  -------------------------------------------
 *          w y0^3 (sqrt (h^2 - y^2)) ^ 3
 *
 * as we only care about the sign,
 *
 * - (y0^3 (w^2 - h^2) + h^2 y (3y0^2 - 2h^2))
 *
 * or (to use accelerators),
 *
 * y0^3 (h^2 - w^2) - h^2 y (3y0^2 - 2h^2) 
 *
 */

/*
 * computes the position on the elipse whose normal line
 * intersects the given scan line maximally
 */

double
hookElipseY (scan_y, def, bound, acc, left)
	double			scan_y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	ret;

	if (acc->h2mw2 == 0) {
		if (scan_y > 0 && !left || scan_y < 0 && left)
			return bound->elipse.min;
		return bound->elipse.max;
	}
	ret = (acc->h4 * scan_y) / (acc->h2mw2);
	if (ret >= 0)
		return pow (ret, 1.0/3.0);
	else
		return -pow (-ret, 1.0/3.0);
}

/*
 * computes the X value of the intersection of the
 * given scan line with the right side of the lower hook
 */

double
hookX (scan_y, def, bound, acc, left)
	double			scan_y;
	struct arc_def		*def;
	struct arc_bound	*bound;
	struct accelerators	*acc;
{
	double	elipse_y, elipse_x, x, xalt;
	double	maxMin;

	elipse_y = hookElipseY (scan_y, def, bound, acc, left);
	if (boundedLe (elipse_y, bound->elipse)) {
		/*
		 * compute the value of the second
		 * derivative
		 */
		maxMin = elipse_y*elipse_y*elipse_y * acc->h2mw2 -
		 acc->h2 * scan_y * (3 * elipse_y*elipse_y - 2*acc->h2);
		if ((left && maxMin > 0) || (!left && maxMin < 0)) {
			if (elipse_y == 0)
				return def->w + left ? -def->l/2 : def->l/2;
			x = (acc->h2 * scan_y - elipse_y * acc->h2mw2) *
				Sqrt (acc->h2 - elipse_y * elipse_y) /
			 	(def->h * def->w * elipse_y);
			return x;
		}
	}
	if (left) {
		if (acc->left.valid && boundedLe (scan_y, bound->left)) {
			x =  acc->left.m * scan_y + acc->left.b;
			if (acc->right.valid && boundedLe (scan_y, bound->right)) {
				xalt = acc->right.m * scan_y + acc->right.b;
				if (xalt < x)
					x = xalt;
			}
		} else {
			if (acc->right.valid)
				x = acc->right.m * scan_y + acc->right.b;
			else
				x = def->w - def->l/2;
		}
	} else {
		if (acc->right.valid && boundedLe (scan_y, bound->right)) {
			x =  acc->right.m * scan_y + acc->right.b;
			if (acc->left.valid && boundedLe (scan_y, bound->left)) {
				xalt = acc->left.m * scan_y + acc->left.b;
				if (xalt > x)
					x = xalt;
			}
		} else {
			if (acc->left.valid)
				x =  acc->left.m * scan_y + acc->left.b;
			else
				x = def->w - def->l/2;
		}
	}
	return x;
}

arcSpan (y, def, bounds, acc)
	double			y;
	struct arc_def		*def;
	struct arc_bound	*bounds;
	struct accelerators	*acc;
{
	double	innerx, outerx;

	if (boundedLt (y, bounds->inner)) {
		/*
		 * intersection with inner edge
		 */
		innerx = innerX (y, def, bounds, acc);
	} else {
		/*
		 * intersection with left face
		 */
		innerx = hookX (y, def, bounds, acc, 1);
	}
	if (boundedLe (y, bounds->outer)) {
		/*
		 * intersection with outer edge
		 */
		outerx = outerX (y, def, bounds, acc);
	} else {
		/*
		 * intersection with right face
		 */
		outerx = hookX (y, def, bounds, acc, 0);
	}
	span (innerx, outerx);
}

/*
 * create whole arcs out of pieces.  This code is
 * very bad.
 */

static double	arcXorigin, arcYorigin;

static struct finalSpan	*firstSpan;
static int		nspans;		/* total spans, not just y coords */

struct finalSpan {
	struct finalSpan	*next;
	int			y;
	struct xrange {
		struct xrange	*next;
		int		min, max;
	}			*spans;
};

fillSpans (pDrawable, pGC)
    DrawablePtr	pDrawable;
    GCPtr	pGC;
{
	struct finalSpan	*f, *next;
	struct xrange		*x, *nextx;
	DDXPointPtr		xSpans, xSpan;
	int			*xWidths, *xWidth;
	int			i;

	if (nspans == 0)
		return;
	xSpan = xSpans = (DDXPointPtr) Xalloc (nspans * sizeof (DDXPointRec));
	xWidth = xWidths = (int *) Xalloc (nspans * sizeof (int));
	i = 0;
	for (f = firstSpan; f; f=next) {
		next = f->next;
		for (x = f->spans; x; x=nextx) {
			nextx = x->next;
			if (x->max > x->min) {
				xSpan->x = x->min;
				xSpan->y = f->y;
				++xSpan;
				*xWidth++ = x->max - x->min;
				++i;
			}
			Xfree (x);
		}
		Xfree (f);
	}
	(*pGC->FillSpans) (pDrawable, pGC, i, xSpans, xWidths, TRUE);
	Xfree (xSpans);
	Xfree (xWidths);
	firstSpan = 0;
	nspans = 0;
}

struct finalSpan *
findSpan (y)
{
	struct finalSpan	*f, *new, *prev;

	prev = 0;
	for (f = firstSpan; f; f=f->next) {
		if (f->y == y)
			return f;
		if (f->y > y)
			break;
		prev = f;
	}
	new = (struct finalSpan *) Xalloc (sizeof (struct finalSpan));
	new->y = y;
	new->spans = 0;
	new->next = f;
	if (prev)
		prev->next = new;
	else
		firstSpan = new;
	return new;
}

newFinalSpan (y, xmin, xmax)
{
	struct finalSpan	*f;
	struct xrange		*x, *oldx, *prev;

	f = findSpan (y);
	oldx = 0;
	for (;;) {
		prev = 0;
		for (x = f->spans; x; x=x->next) {
			if (x == oldx) {
				prev = x;
				continue;
			}
			if (x->min <= xmax && xmin <= x->max) {
				if (oldx) {
					oldx->min = min (x->min, xmin);
					oldx->max = max (x->max, xmax);
					if (prev)
						prev->next = x->next;
					else
						f->spans = x->next;
					--nspans;
					free (x);
				} else {
					x->min = min (x->min, xmin);
					x->max = max (x->max, xmax);
					oldx = x;
				}
				xmin = oldx->min;
				xmax = oldx->max;
				break;
			}
			prev = x;
		}
		if (!x)
			break;
	}
	if (!oldx) {
		x = (struct xrange *) Xalloc (sizeof (struct xrange));
		x->min = xmin;
		x->max = xmax;
		x->next = f->spans;
		f->spans = x;
		++nspans;
	}
}

mirrorSpan (quadrant, y, min, max)
	double		y;
	double		min, max;
{
	int		spany, xmin, xmax;
	double		t;

	switch (quadrant) {
	case 0:
		break;
	case 1:
		t = -max;
		max = -min;
		min = t;
		break;
	case 2:
		t = -max;
		max = -min;
		min = t;
		y = -y;
		break;
	case 3:
		y = -y;
		break;
	}
	xmin = (int) ceil (arcXorigin + min - NEWTON_LIMIT);
	xmax = (int) ceil (arcXorigin + max - NEWTON_LIMIT);
	spany = (int) (ceil (arcYorigin + y));
	if (xmax > xmin)
		newFinalSpan (spany, xmin, xmax);
}

static int	quadrantMask;

mergeSpan (y, min, max)
	double	y, min, max;
{
	if (quadrantMask & 1)
		mirrorSpan (0, y, min, max);
	if (quadrantMask & 2)
		mirrorSpan (1, y, min, max);
	if (quadrantMask & 4)
		mirrorSpan (2, y, min, max);
	if (quadrantMask & 8)
		mirrorSpan (3, y, min, max);
}

static double	spanY;

drawArc (x0, y0, w, h, l, a0, a1)
	int	x0, y0, w, h, l, a0, a1;
{
	struct arc_def		def;
	struct accelerators	acc;
	struct span		*result;
	int			startq, endq, curq;
	int			q0, q1, mask;
	struct band {
		int	a0, a1;
		int	mask;
	}	band[5], sweep[20];
	int			bandno, sweepno;
	int			i, j, k;

	def.w = ((double) w) / 2;
	def.h = ((double) h) / 2;
        arcXorigin = (double) x0 + def.w;
	arcYorigin = (double) y0 + def.h;
	def.l = (double) l;
	if (a1 < a0)
		a1 += 360 * 64;
	startq = a0 / (90 * 64);
	endq = (a1-1) / (90 * 64);
	bandno = 0;
	curq = startq;
	for (;;) {
		switch (curq) {
		case 0:
			if (a0 > 90 * 64)
				q0 = 0;
			else
				q0 = a0;
			if (a1 < 360 * 64)
				q1 = min (a1, 90 * 64);
			else
				q1 = 90 * 64;
			break;
		case 1:
			if (a1 < 90 * 64)
				q0 = 0;
			else
				q0 = 180 * 64 - min (a1, 180 * 64);
			if (a0 > 180 * 64)
				q1 = 90 * 64;
			else
				q1 = 180 * 64 - max (a0, 90 * 64);
			break;
		case 2:
			if (a0 > 270 * 64)
				q0 = 0;
			else
				q0 = max (a0, 180 * 64) - 180 * 64;
			if (a1 < 180 * 64)
				q1 = 90 * 64;
			else
				q1 = min (a1, 270 * 64) - 180 * 64;
			break;
		case 3:
			if (a1 < 270 * 64)
				q0 = 0;
			else
				q0 = 360 * 64 - min (a1, 360 * 64);
			q1 = 360 * 64 - max (a0, 270 * 64);
			break;
		}
		band[bandno].a0 = q0;
		band[bandno].a1 = q1;
		band[bandno].mask = 1 << curq;
		bandno++;
		if (curq == endq)
			break;
		curq++;
		if (curq == 4) {
			a0 = 0;
			a1 -= 360 * 64;
			curq = 0;
			endq -= 4;
		}
	}
	sweepno = 0;
	for (;;) {
		q0 = 90 * 64;
		mask = 0;
		/*
		 * find left-most point
		 */
		for (i = 0; i < bandno; i++)
			if (band[i].a0 < q0) {
				q0 = band[i].a0;
				q1 = band[i].a1;
				mask = band[i].mask;
			}
		if (!mask)
			break;
		/*
		 * locate next point of change
		 */
		for (i = 0; i < bandno; i++)
			if (!(mask & band[i].mask)) {
				if (band[i].a0 == q0) {
					if (band[i].a1 < q1)
						q1 = band[i].a1;
					mask |= band[i].mask;
 				} else if (band[i].a0 < q1)
					q1 = band[i].a0;
			}
		/*
		 * create a new sweep
		 */
		sweep[sweepno].a0 = q0;
		sweep[sweepno].a1 = q1;
		sweep[sweepno].mask = mask;
		sweepno++;
		/*
		 * subtract the sweep from the affected bands
		 */
		for (i = 0; i < bandno; i++)
			if (band[i].a0 == q0) {
				band[i].a0 = q1;
				/*
				 * check if this band is empty
				 */
				if (band[i].a0 == band[i].a1)
					band[i].a1 = band[i].a0 = 90 * 64;
			}
	}
	computeAcc (&def, &acc);
	for (j = 0; j < sweepno; j++) {
		quadrantMask = sweep[j].mask;
		drawQuadrant (&def, &acc, sweep[j].a0, sweep[j].a1);
	}
}

drawQuadrant (def, acc, a0, a1)
	struct arc_def		*def;
	struct accelerators	*acc;
	int			a0, a1;
{
	struct arc_bound	bound;
	double			miny, maxy, y;

	def->a0 = ((double) a0) / 64.0;
	def->a1 = ((double) a1) / 64.0;
	computeBound (def, &bound, acc);
	miny = fmin (ceil (bound.inner.min), ceil (bound.outer.min));
	maxy = fmax (floor (bound.inner.max), floor (bound.outer.max));
	for (y = miny; y <= maxy; y = y + 1.0) {
		spanY = y;
		arcSpan (y, def, &bound, acc);
	}
	/*
	 * add the pixel at the top of the arc
	 */
	if (a1 == 90 * 64 && (quadrantMask & 1) && ((int) (def->w * 2)) & 1)
		mirrorSpan (0, - (def->h + def->l/2), 0.0, 1.0);
}

max (x, y)
{
	return x>y? x:y;
}

min (x, y)
{
	return x<y? x:y;
}

span (left, right)
double	left, right;
{
	mergeSpan (spanY, left, right);
}
