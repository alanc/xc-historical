/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/* $XConsortium: miarc.c,v 1.51 88/09/02 16:36:06 matt Exp $ */
/* Author: Todd Newman */
#include "X.h"
#include "Xprotostr.h"
#include "misc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mifpoly.h"
#include "mi.h"

extern double sqrt(), cos(), sin(), atan();
/* these are from our <math.h>, but I'm told some systems don't have
 * math.h and that they're not in all versions of math.h.  Psi! */
#define M_PI	3.14159265358979323846
#define M_PI_2	1.57079632679489661923
#ifndef X_AXIS
# define X_AXIS 0
# define Y_AXIS 1
#endif X_AXIS
/* 360 degrees * 64 sub-degree positions */
#define FULLCIRCLE 64 * 360

/* This contains the information needed to draw one arc of a polyarc.
 * An array of them can be allocated if the polyarc has more than 1 part */
typedef struct
{
    int		cpt;
    SppPointPtr	pPts;
} POLYARCINFO;

/* ARCDASH - an individual dash, part of a set of arcs */
typedef struct _miArcDash {
    int         npts;		/* number of points in this dash */
    SppPointPtr pts;		/* array of points in this dash */
    xArc        arc;		/* for miArcSegment - XXX */
} miArcDashRec, *miArcDashPtr;

/* ARCJOIN - an individual join, part of a set of arcs */
typedef struct _miArcJoin {
    SppPointRec juncture;	/* central point where they collide */
    /* points travelling back into each arc away from the open join */
    SppPointRec prev[2];
} miArcJoinRec, *miArcJoinPtr;

/* ARCCAP  - an individual join, part of a set of arcs */
typedef struct _miArcCap {
    SppPointRec juncture;	/* central point where it touches the arc */
    /* point travelling back into the arc away from the desired cap */
    SppPointRec prev;
} miArcCapRec, *miArcCapPtr;

/* This is an entire sequence of arcs, computed and categorized according *
 *  to operation.  The interpreting code better be damn fast!             *
 * Need one of these for even and one for odd stuff.                      */
typedef struct _miDashedArc {
    int          ndashes, njoins, ncaps; /* number of each thingie */
    miArcDashPtr dashes;	/* array of the dashes of this type */
    miArcJoinPtr joins;		/* array of the joins  of this type */
    miArcCapPtr  caps;		/* array of the caps   of this type */
} miDashedArcRec, *miDashedArcPtr;

static miDashedArcPtr miDashArcs();    

#define GCValsFunction		0
#define GCValsForeground 	1
#define GCValsBackground 	2
#define GCValsLineWidth 	3
#define GCValsCapStyle 		4
#define GCValsJoinStyle		5
#define GCValsMask		(GCFunction | GCForeground | GCBackground | \
				 GCLineWidth | GCCapStyle | GCJoinStyle)
static CARD32 gcvals[]= {GXcopy, 1, 0, 0, 0, 0};

/* MIINTERPARC - generate another point past the end of an arc.  This
 *  point is not really part of the arc, but its connection with the
 *  previous point has an exact slope.
 * Calculus voodoo magic...hold on to your chickens!
 * Determine the slope at each of the endpoints using partial
 *  differentiation.  (remember?)  The endpoint slopes must be exact
 *  or the resulting butt faces will have utterly bogus slopes.
 * The resultant point is generated by rotating backwards AWAY from a2.
 */
static void
#ifndef COMPUTEXANDY		/* passed */
miInterpArc( tarc, a1, a2, ppt, x, y )
#else				/* not passed */
miInterpArc( tarc, a1, a2, ppt )
#endif
    xArc        tarc;		/* promise not to look at angles in arc! */
    int         a1, a2;		/* the angles i can look at */
    SppPointPtr ppt;		/* the result is put here */
#ifndef COMPUTEXANDY
    double      x, y;
#endif
{
    double dx, dy, hyp;
#ifdef COMPUTEXANDY		/* not arguments */
    double x, y;
#endif

#ifdef COMPUTEXANDY		/* not arguments */
    x = tarc.x + tarc.width *
	(cos(((double) (-a1) *
	      ((double) M_PI)) / (64 * 180)) + 1.0) / 2.0;
    y = tarc.y + tarc.height *
	(sin(((double) (-a1) *
	      ((double) M_PI)) / (64 * 180)) + 1.0) / 2.0;
#endif
    dx = x - (tarc.x + tarc.width/2.0);
    dy = y - (tarc.y + tarc.height/2.0);
    /* x and y are really the drawable coordinates of the start. *
     * dx is (x - xc), where xc is the center point of the ellipse.  *
     * ditto for dy.                                                     */
    if (ISZERO(dy))		/* infinite slope */
    {
	ppt->x = x;
	ppt->y = y +
	    ((((a1 <= 90*64 || a1 >= 270*64) &&
	       (a2 >= 0)) ||
	      ((a1 >= 90*64 && a1 <= 270*64) &&
	       (a2 <= 0))) ?
	     (1.0) : (-1.0));
    } else {		/* managable slope */
	hyp = ((a1 <= 180*64) ?
	       (a2 >= 0) : (a2 <= 0)) ?
		   (1.0) : (-1.0);
	ppt->x = x + hyp;
	ppt->y = y -
	    ((hyp >= 0.0) ?
	     (dx * tarc.height * tarc.height) :
	     (-dx * tarc.height * tarc.height)) /
		 (dy * tarc.width * tarc.width);
    }
}

/* MIARCSEGMENT -- private arc helper.                                      *
 * Draws one arc with miGetArcPts and the double precision polygon helper.  *
 * Does not handle joins or caps.  Will NOT plot any points more than once. *
 * Ending faces will be precisely flush with perfect slope.   Oooh mama.    *
 * p.s.  this interface sucks.  sorry.                                      */

static void
miArcSegment(pDraw, pGC, tarc, hasPts, pArgPts, nArgPts )
    DrawablePtr   pDraw;
    GCPtr         pGC;
    xArc          tarc;
    Bool          hasPts;
    SppPointPtr   pArgPts;	/* only valid if hasPts == TRUE */
    int           nArgPts;
{
    SppPointPtr   pPts;		/* Points for the current arc */
    SppPointPtr   pGotPts;	/* Points returned from miGetArcPts */
    register int  width = pGC->lineWidth;
    register int  ifirst, cpt;
    int           base, a2, ta2;
    double        dx, dy, tmpdx, tmpdy, hyp;
    extern double hypot();

    /* random (necessary) paranoia checks.  specialized routines could be *
     * written for each of these cases, but who has the time?             */
    if (width < 1)
	width = 1;		/* for 0-width arcs */
    if (tarc.width == 0)
	tarc.width = 1;
    if (tarc.height == 0)
	tarc.height = 1;
    
    if (tarc.angle2 > FULLCIRCLE)
	tarc.angle2 = FULLCIRCLE;
    else if (tarc.angle2 < -FULLCIRCLE)
	tarc.angle2 = -FULLCIRCLE;
    while (abs(tarc.angle2) > 0)
    {
	if (tarc.angle1 > 0)
	{
	    while (tarc.angle1 >= FULLCIRCLE)
		tarc.angle1 -= 360 * 64;
	} else {
	    while (tarc.angle1 < 0)
		tarc.angle1 += 360 * 64;
	}
	/* angle1 in [0,360) and angle2 in [-360,360] */
	a2 = tarc.angle2;
	if (tarc.angle2 > 0)
	{		/* counter-clockwise */
	    base = tarc.angle1 / (90 * 64);	/* in [0,3] */
	    base *= 90*64;	/* in {0, 90, 180, 270} */
	    base += 90*64;	/* in {90, 180, 270, 360} */
	    tarc.angle2 = min(base - tarc.angle1, tarc.angle2);
	} else {	/* clockwise */
	    base = (tarc.angle1-1) / (90 * 64);	/* in [0,3] */
	    base *= 90*64;	/* in {0, 90, 180, 270} */
	    if (tarc.angle1 == 0)
		tarc.angle2 = max(-90*64, tarc.angle2);
	    else
		tarc.angle2 = max(base - tarc.angle1, tarc.angle2);
	}

	/* --- pGotPts - start --------------------------------- */
	/* The pGotPts array needs the points from miGetPts and 2 extra:  *
	 * [0]       = An initial bogus point that will generate the correct *
	 *             slope for the first destination point                 *
	 * [1]       = First point from miGetArcPts                          *
	 * [2]       = The second point returned from miGetArcPts (1st used) *
	 * [cpt]     = The last point returned from miGetArcPts (last used)  *
	 * [cpt+1]   = The bogus point used to generate exact final slope    */

	/* now get the centered arc points.  note that the point generated *
	 * above and preserved below is NOT part of the arc, it just makes *
         * the slope from pt[0] to pt[1] correct at pt[1].                 */
	if (hasPts)
	{			/* yes, we have storage! */
	    if (tarc.angle2 != a2)
	    {
		hasPts = FALSE;	/* points are useless */
		Xfree( pArgPts );
	    } else {
		pPts = pArgPts;
	    
		miInterpArc( tarc, tarc.angle1, tarc.angle2, &pPts[0],
			    pPts[1].x, pPts[1].y);
	    
		cpt = nArgPts - 1;
	    }
	}			/* might fall through to the next one... */
	if (!(hasPts))
	{			/* generate points */
	    if (!(pPts = (SppPointPtr) Xalloc( sizeof(SppPointRec) )))
		return;
	    
	    if (!(cpt = miGetArcPts(&tarc, 1, &pPts)))
		return;
	
	    miInterpArc( tarc, tarc.angle1, tarc.angle2, &pPts[0],
			pPts[1].x, pPts[1].y);
	    
	    if (!(pPts = (SppPointPtr)
		  Xrealloc(pPts, (cpt+2) * sizeof(SppPointRec))))
		return;		/* should we free the old one? */
	}
	
	/* Calculus for final arc point (see comments above). */
	ta2 = tarc.angle1 + tarc.angle2;
	if (ta2 >= 360*64)
	    ta2 -= 360*64;
	else if (ta2 < 0)
	    ta2 += 360*64;	/* ta2 now in [0,360) */
	miInterpArc( tarc, ta2, - tarc.angle2, &pPts[cpt+1],
		    pPts[cpt].x, pPts[cpt].y);

	pGotPts = pPts;		/* now complete */
	tarc.angle1 += tarc.angle2;     /* for the next pass through... */
	tarc.angle2 = a2 - tarc.angle2;	/*   ...in case of partial arcs */

	/* --- pGotPts - done ----------------- pPts - start --- */
	/* Note that the polygon generated goes from the starting outer edge *
	 *  to the ending outer edge to the ending inner edge to the 1st     *
	 *  inner edge.  BTW:  it's not really convex either, but it works!  *
	 * The pPts array is the final product to drawn.                     *
	 * [0]       = The outer starting point and first legal address      *
	 * [cpt-1]   = The outer ending point                                *
	 * [cpt]     = The inner ending point                                *
	 * [2*cpt-1] = The inner starting point                              */

	if (!(pPts = (SppPointPtr)
	      Xalloc(2 * cpt * sizeof(SppPointRec))))
	{
	    Xfree((pointer) pGotPts);
	    return;
	}
	
	/* now have to generate the start of the polygon *
	 * by hand to insure the proper slope.           */
	tmpdx = pGotPts[0].x - pGotPts[1].x;
	tmpdy = pGotPts[0].y - pGotPts[1].y;
	hyp = hypot(tmpdx, tmpdy);
	    
	if (!ISZERO(hyp))
	{
	    dy = (tmpdx * width/2.0) / hyp;
	    dx = (tmpdy * width/2.0) / hyp;
	    
	    pPts[2*cpt-1].x = pGotPts[1].x - dx;
	    pPts[2*cpt-1].y = pGotPts[1].y + dy;
	    pPts[0].x       = pGotPts[1].x + dx;
	    pPts[0].y       = pGotPts[1].y - dy;
	} else {
	    ErrorF("Wide Arc: First inline miGetPts had 0 length\n");
	    Xfree((pointer) pGotPts);
	    Xfree((pointer) pPts);
	    return;	/* doomed... */
	}
	
	for (ifirst = 2; ifirst <= cpt; ifirst++)
	{			/* finish the remaining points */
	    tmpdx = pGotPts[ifirst].x - pGotPts[ifirst+1].x;
	    tmpdy = pGotPts[ifirst].y - pGotPts[ifirst+1].y;
	    hyp = hypot(tmpdx, tmpdy);
	    
	    if (!ISZERO(hyp))
	    {
		dy = (tmpdx * width/2.0) / hyp;
		dx = (tmpdy * width/2.0) / hyp;
		
		pPts[2*cpt-ifirst].x = pGotPts[ifirst].x - dx;
		pPts[2*cpt-ifirst].y = pGotPts[ifirst].y + dy;
		pPts[ifirst-1].x     = pGotPts[ifirst].x + dx;
		pPts[ifirst-1].y     = pGotPts[ifirst].y - dy;
	    } else {
		ErrorF("Wide Arc: Looping inline miGetPts had 0 length\n");
		Xfree((pointer) pGotPts);
		Xfree((pointer) pPts);
		return;	/* doomed... */
	    }
	}
	Xfree((pointer) pGotPts);
	miFillSppPoly(pDraw, pGC, cpt * 2, pPts, 0, 0);
	Xfree((pointer) pPts);
    }
}

/* MIPOLYARC -- Public entry for the polyarc call.
 * Strategy: Similar in many ways to that for wide lines.
 * In general, we will each arc segment as a polyline. (We can make the arc
 * arbitrarily smooth by increasing the number of segments and shortening
 * the length of each segment.)
 * If there's only 1 arc, or if the arc is draw with zero width lines, we 
 * don't have to worry about the rasterop or join styles.   
 * Otherwise, we set up pDrawTo and pGCTo according to the rasterop, then
 * draw using pGCTo and pDrawTo.  If the raster-op was "tricky," that is,
 * if it involves the destination, then we use PushPixels to move the bits
 * from the scratch drawable to pDraw. (See the wide line code for a
 * fuller explanation of this.)
 */
void
miPolyArc(pDraw, pGC, narcs, parcs)
    DrawablePtr	pDraw;
    GCPtr	pGC;
    int		narcs;
    xArc	*parcs;
{
    register int		i;
    register SppPointPtr	ppt;	/* Points for the current arc */
    register SppPointPtr	pAllPts; /* Points for all arcs so far */
    register int		cpt,	/* count of points in current arc */
    				cptAll;	/* count of points in all arcs */
    SppPointPtr			pPts;	/* Points for the current arc */
    double			xMin, xMax, yMin, yMax, yOrg, xOrg, dx, dy;
    int				ifirst, count, width;
    Bool			fTricky;
    DrawablePtr			pDrawTo;
    GCPtr			pGCTo;
    register POLYARCINFO	*polyarcs;

    width = pGC->lineWidth;
    if(width == 0 || narcs == 1)
    {
	if (pGC->lineStyle != LineSolid)
	{
	    int            iphase;
	    miDashedArcPtr dashes;

	    if (!(dashes = miDashArcs(parcs, narcs,
				      pGC->dash, pGC->numInDashList,
				      pGC->dashOffset,
				      (pGC->lineStyle == LineDoubleDash))))
		return;
	    for (iphase = 0; iphase <
		 ((pGC->lineStyle == LineDoubleDash) ? 2 : 1); iphase++)
	    {
		for (i = 0; i < dashes[iphase].ndashes; i++)
		{
		    miArcSegment(pDraw, pGC, dashes[iphase].dashes[i].arc,
				 TRUE, dashes[iphase].dashes[i].pts,
				 dashes[iphase].dashes[i].npts);
		}
		Xfree((pointer) dashes[iphase].dashes);
	    }
	    Xfree((pointer) dashes);
	} else {
	    for(i = 0; i < narcs; i++)
		miArcSegment( pDraw, pGC, parcs[i],
			     FALSE, (SppPointPtr) NULL, 0 );
	}
    }
    else 
    {
	polyarcs = (POLYARCINFO *)ALLOCATE_LOCAL(narcs * sizeof(POLYARCINFO));
	if(!polyarcs)
	    return;

	xMin = yMin = MAXSHORT;
	xMax = yMax = MINSHORT;

	/* Get all points for all the arcs. */
	for(i = 0; i < narcs; i++)
	{
	    pPts = (SppPointPtr) NULL;
	    cpt = miGetArcPts(&parcs[i], 0, &pPts);
	    polyarcs[i].cpt = cpt;
	    polyarcs[i].pPts = pPts;
	    for(ppt = pPts, count = cpt; --count >= 0; ppt++)
	    {
		xMin = min(xMin, ppt->x);
		yMin = min(yMin, ppt->y);
		xMax = max(xMax, ppt->x);
		yMax = max(yMax, ppt->y);
	    }
	}
	/* Set up pDrawTo and pGCTo based on the rasterop */
	switch(pGC->alu)
	{
	  case GXclear:		/* 0 */
	  case GXcopy:		/* src */
	  case GXcopyInverted:	/* NOT src */
	  case GXset:		/* 1 */
	    fTricky = FALSE;
	    pDrawTo = pDraw;
	    pGCTo = pGC;
	    break;
	  default:
	    fTricky = TRUE;

	    pGCTo = GetScratchGC(1, pDraw->pScreen);
	    gcvals[GCValsLineWidth] = pGC->lineWidth;
	    gcvals[GCValsCapStyle] = pGC->capStyle;
	    gcvals[GCValsJoinStyle] = pGC->joinStyle;
	    DoChangeGC(pGCTo, GCValsMask, gcvals, 0);
    
    	    xOrg = xMin - ((double) width + 1)/2;
	    yOrg = yMin - ((double) width + 1)/2;
	    dx = xMax - xMin + ((double) width) + 1;
	    dy = yMax - yMin + ((double) width) + 1;
	    for(i = 0; i < narcs; i++)
	    {
		for(ppt = polyarcs[i].pPts, count = polyarcs[i].cpt;
		    --count >= 0;
		    ppt++)
		{
		    ppt->x -= xOrg;
		    ppt->y -= yOrg;
		}
	    }
	    if (pGC->miTranslate && (pDraw->type == DRAWABLE_WINDOW))
	    {
		xOrg += (double) ((WindowPtr)pDraw)->absCorner.x;
		yOrg += (double) ((WindowPtr)pDraw)->absCorner.y;
	    }

	    /* allocate a 1 bit deep pixmap of the appropriate size, and
	     * validate it */
	    pDrawTo = (DrawablePtr)(*pDraw->pScreen->CreatePixmap)
					(pDraw->pScreen, dx, dy, 1, XYBitmap);
	    ValidateGC(pDrawTo, pGCTo);
	    miClearDrawable(pDrawTo, pGCTo);
	}

	ifirst = 0;

	if (polyarcs[0].cpt) {
	    SppPointRec pt0, ptn;

	    for (i = narcs - 1;
		 (i >= 0) && (cpt = polyarcs[i].cpt);
		 ifirst = i, i--) {
		pt0 = polyarcs[ifirst].pPts[0],
		ptn = polyarcs[i].pPts[cpt - 1];
		
		if (PTUNEQUAL(pt0, ptn))
		    break;
	    }
	}
	
	cptAll = 0;
	pAllPts = (SppPointPtr) NULL;

	for(i = ifirst, count = narcs; --count >= 0; i++)
	{
	    if (i == narcs)
		i = 0;	/* wrap */

	    cpt = polyarcs[i].cpt;
	    pPts = polyarcs[i].pPts;

	    if((cpt > 0) && (cptAll > 0) &&
	       PTISEQUAL(pPts[0], pAllPts[cptAll-1]))
	    {			/* join between arcs here - XXX */
		cpt--;
		if (!(pAllPts = (SppPointPtr)
		      Xrealloc((pointer)pAllPts,
			       (cptAll + cpt) * sizeof(SppPointRec))))
		    return;
		bcopy((char *)&pPts[1],
		      (char *)&pAllPts[cptAll], 
		      cpt * sizeof(SppPointRec));
		Xfree((pointer)pPts);
		cptAll += cpt;
	    }
	    else
	    {			/* this arc does not join to any other arc */
		/* Flush what we have so far and start collecting again */
		if(cptAll > 0)
		{
		    (*pGCTo->LineHelper) (pDrawTo, pGCTo,
					  !(pGC->lineStyle == LineDoubleDash),
					  cptAll, pAllPts, 0, 0);
		    Xfree((pointer)pAllPts);
		    if(fTricky)
		    {
		        (*pGC->PushPixels)(pGC, pDrawTo, pDraw, (int) dx,
					   (int) dy, (int) xOrg, (int) yOrg);
		        miClearDrawable((DrawablePtr)pDrawTo, pGCTo);
		    }
		}
		cptAll = cpt;
		pAllPts = pPts;
	    }
	}

	if (cptAll > 0)
	{			/* this may be two joined arcs or one arc */
	    (*pGCTo->LineHelper) (pDrawTo, pGCTo,
				  !(pGC->lineStyle == LineDoubleDash),
				  cptAll, pAllPts, 0, 0);
	    Xfree((pointer)pAllPts);
	    if(fTricky)
		(*pGC->PushPixels)(pGC, pDrawTo, pDraw, (int) dx, (int) dy,
				   (int) xOrg, (int) yOrg);
	}
	if(fTricky)
	{
	    (*pGCTo->pScreen->DestroyPixmap)((PixmapPtr)pDrawTo);
	    FreeScratchGC(pGCTo);
	}
	DEALLOCATE_LOCAL(polyarcs);
    }
}

/* MIPOLYFILLARC -- The public entry for the PolyFillArc request.
 * Since we don't have to worry about overlapping segments, we can just
 * fill each arc as it comes.  As above, we convert the arc into a set of
 * line segments and then fill the resulting polygon.
 */
void
miPolyFillArc(pDraw, pGC, narcs, parcs)
    DrawablePtr	pDraw;
    GCPtr	pGC;
    int		narcs;
    xArc	*parcs;
{
    int	i, cpt;
    SppPointPtr pPts;

    for(i = 0; i < narcs; i++)
    {
	/* We do this test every time because a full circle PieSlice isn't
	 * really a slice, but a full pie, and the Chord code (below) should
	 * handle it better */
        if(pGC->arcMode == ArcPieSlice && parcs[i].angle2 < FULLCIRCLE)
	{
	    if (!(pPts = (SppPointPtr)Xalloc(sizeof(SppPointRec))))
		return;
	    if(cpt = miGetArcPts(&parcs[i], 1, &pPts))
	    {
		pPts[0].x = (double) (parcs[i].x +
				      ((double) parcs[i].width)/2);
		pPts[0].y = (double) (parcs[i].y +
				      ((double) parcs[i].height)/2);
		miFillSppPoly(pDraw, pGC, cpt + 1, pPts, 0, 0);
		Xfree((pointer) pPts);
	    }
	}
        else /* Chord */
	{
	    pPts = (SppPointPtr)NULL;
	    if(cpt = miGetArcPts(&parcs[i], 0, &pPts))
	    {
		miFillSppPoly(pDraw, pGC, cpt, pPts, 0, 0);
		Xfree((pointer) pPts);
	    }
	}
    }
}

#define REALLOC_STEP 10		/* how often to realloc */
/* MIGETARCPTS -- Converts an arc into a set of line segments -- a helper
 * routine for arc and line (round cap) code.
 * Returns the number of points in the arc.  Note that it takes a pointer
 * to a pointer to where it should put the points and an index (cpt).
 * This procedure allocates the space necessary to fit the arc points.
 * Sometimes it's convenient for those points to be at the end of an existing
 * array. (For example, if we want to leave a spare point to make sectors
 * instead of segments.)  So we pass in the Xalloc()ed chunk that contains the
 * array and an index saying where we should start stashing the points.
 * If there isn't an array already, we just pass in a null pointer and 
 * count on Xrealloc() to handle the null pointer correctly.
 */
int
miGetArcPts(parc, cpt, ppPts)
    xArc	*parc;	/* points to an arc */
    int		cpt;	/* number of points already in arc list */
    SppPointPtr	*ppPts; /* pointer to pointer to arc-list -- modified */
{
    double 	st,	/* Start Theta, start angle */
                et,	/* End Theta, offset from start theta */
		dt,	/* Delta Theta, angle to sweep ellipse */
		cdt,	/* Cos Delta Theta, actually 2 cos(dt) */
    		x0, y0,	/* the recurrence formula needs two points to start */
		x1, y1,
		x2, y2, /* this will be the new point generated */
		xc, yc, /* the center point */
                xt, yt;	/* possible next point */
    int		count, i, axis, npts = 2; /* # points used thus far */
    double      asin();
    SppPointPtr	poly;
    DDXPointRec last;		/* last point on integer boundaries */

    /* The spec says that positive angles indicate counterclockwise motion.
     * Given our coordinate system (with 0,0 in the upper left corner), 
     * the screen appears flipped in Y.  The easiest fix is to negate the
     * angles given */
    
    /* Throw out multiples of 360 degrees. */
    i = -parc->angle1;
    if(i < 0)
    {
	while (i < -FULLCIRCLE)
	    i += FULLCIRCLE;
    }
    else
    {
	while(i > FULLCIRCLE)
	    i -= FULLCIRCLE;
    }
    st = (double ) i;
    st *= ((double)M_PI) / (64 * 180); 	/* convert to degrees, then to rads */

    i = -parc->angle2;
    /* If it's more than one full rotation, make it exactly 1 rotation */
    if (i > FULLCIRCLE)
	i = FULLCIRCLE;
    if (i < -FULLCIRCLE)
	i = -FULLCIRCLE;
    et = (double) i;
    et *= ((double)M_PI) / (64 * 180); 	/* convert to degrees, then to rads */

    /* Try to get a delta theta that is within 1/2 pixel.  Then adjust it
     * so that it divides evenly into the total.
     * I'm just using cdt 'cause I'm lazy.
     */
    cdt = max(parc->width, parc->height)/2.0;
    if(cdt <= 0)
	return 0;
    dt = asin( ((double) 1) / cdt ); /* minimum step necessary */
    count = et/dt;
    count = abs(count) + 1;
    dt = et/count;	
    count++;

    cdt = 2 * cos(dt);
#ifdef NOARCCOMPRESSION
    if (!(poly = (SppPointPtr) Xrealloc((pointer)*ppPts,
					(cpt + count) * sizeof(SppPointRec))))
	return(0);
    *ppPts = poly;
#else				/* ARCCOMPRESSION */
    if (!(poly = (SppPointPtr) Xrealloc((pointer)*ppPts,
					(cpt + 2) * sizeof(SppPointRec))))
	return(0);
#endif				/* ARCCOMPRESSION */

    xc = parc->width/2.0;		/* store half width and half height */
    yc = parc->height/2.0;
    axis = (xc >= yc) ? X_AXIS : Y_AXIS;
    
    x0 = xc * cos(st);
    y0 = yc * sin(st);
    x1 = xc * cos(st + dt);
    y1 = yc * sin(st + dt);
    xc += parc->x;		/* by adding initial point, these become */
    yc += parc->y;		/* the center point */

    poly[cpt].x = (xc + x0);
    poly[cpt].y = (yc + y0);
    last.x = ROUNDTOINT( poly[cpt + 1].x = (xc + x1) );
    last.y = ROUNDTOINT( poly[cpt + 1].y = (yc + y1) );

    for(i = 2; i < count; i++)
    {
	x2 = cdt * x1 - x0;
	y2 = cdt * y1 - y0;

#ifdef NOARCCOMPRESSION
 	poly[cpt + i].x = (xc + x2);
 	poly[cpt + i].y = (yc + y2);
#else				/* ARCCOMPRESSION */
	xt = xc + x2;
	yt = yc + y2;
 	if (((axis == X_AXIS) ?
	     (ROUNDTOINT(yt) != last.y) :
	     (ROUNDTOINT(xt) != last.x)) ||
	    i > count - 3)	/* insure 2 at the end */
 	{
	    /* allocate more space if we are about to need it */
	    /* include 1 extra in case minor axis swaps */
 	    if ((npts - 2) % REALLOC_STEP == 0)
	    {
 		if (!(poly = (SppPointPtr)
		      Xrealloc((pointer) poly,
			       ((npts + REALLOC_STEP + cpt) *
				sizeof(SppPointRec)))))
		    return(0);
	    }
	    /* check if we just switched direction in the minor axis */
	    if (((poly[cpt + npts - 2].y - poly[cpt + npts - 1].y > 0.0) ?
		 (yt - poly[cpt + npts - 1].y > 0.0) :
		 (poly[cpt + npts - 1].y - yt > 0.0)) ||
		((poly[cpt + npts - 2].x - poly[cpt + npts - 1].x > 0.0) ?
		 (xt - poly[cpt + npts - 1].x > 0.0) :
		 (poly[cpt + npts - 1].x - xt > 0.0)))
	    {
		/* Since the minor axis direction just switched, the final *
		 * point before the change must be included, or the        *
		 * following segment will begin before the minor swap.     */
		poly[cpt + npts].x = xc + x1;
		poly[cpt + npts].y = yc + y1;
		npts++;
		if ((npts - 2) % REALLOC_STEP == 0)
		{
		    if (!(poly = (SppPointPtr)
			  Xrealloc((pointer) poly,
				   ((npts + REALLOC_STEP + cpt) *
				    sizeof(SppPointRec)))))
			return(0);
		}
	    }
 	    last.x = ROUNDTOINT( poly[cpt + npts].x = xt );
 	    last.y = ROUNDTOINT( poly[cpt + npts].y = yt );
 	    npts++;
 	}
#endif				/* ARCCOMPRESSION */

	x0 = x1; y0 = y1;
	x1 = x2; y1 = y2;
    }
#ifndef NOARCCOMPRESSION	/* i.e.:  ARCCOMPRESSION */
    count = i = npts;
#endif				/* ARCCOMPRESSION */
    /* adjust the last point */
    if (abs(parc->angle2) >= FULLCIRCLE)
	poly[cpt +i -1] = poly[0];
    else {
	poly[cpt +i -1].x = (cos(st + et) * parc->width/2.0 + xc);
	poly[cpt +i -1].y = (sin(st + et) * parc->height/2.0 + yc);
    }

#ifndef NOARCCOMPRESSION	/* i.e.:  ARCCOMPRESSION */
    *ppPts = poly;		/* may have changed during reallocs */
#endif				/* ARCCOMPRESSION */
    return(count);
}

/* MIDASHARCS -- Converts a list of arcs to a list of dashed arcs.            *
 * Each dashed arc is represented as a record with the number of sub-arcs in  *
 *  the entire dashed arc, and then an array of all the sub-arcs.  Each sub-  *
 *  arc consists of arc segments with assigned phase and a list of double-    *
 *  precision points.                                                         *
 * This routine can parse an entire list of arcs as passed to PolyArc, since  *
 *  it checks for point connection before applying the dash offset.  That is, *
 *  if the next arc begins where the last one ends, then the current offset   *
 *  is retained, otherwise the current offset and dash phase is recomputed    *
 *  based on the passed offset.                                               *
 * The passed pointer of arc-dashes should actually be an array of the same   *
 *  size as the array of argument arcs.  It will be filled in by the routine. *
 *  The number of arcs filled in will be returned.  It should be equal to the *
 *  number of arcs passed.                                                    *
 */
/* Either returns a pointer to the even dashes or an array of the even and *
 * then the odd dashed arcs.                                               */
static miDashedArcPtr
miDashArcs(pArc, nArcs, pDash, nDashes, dashOffset, isDoubleDash)
    xArc	  *pArc;	/* array of arcs to dash */
    int		  nArcs;	/* number of arcs in passed arc array */
    unsigned char *pDash;
    int           nDashes;
    int           dashOffset;	/* for dashes -- from gc */
    Bool          isDoubleDash;	/* TRUE if double dashed, otherwise onoff */
{
    double 	 st,	/* Start Theta, start angle */
                 et,	/* End Theta, offset from start theta */
		 dt,	/* Delta Theta, angle to sweep ellipse */
		 cdt,	/* Cos Delta Theta, actually 2 cos(dt) */
    		 x0, y0, /* the recurrence formula needs two points to start */
		 x1, y1,
		 x2, y2, /* this will be the new point generated */
		 xc, yc, /* the center point */
                 xt, yt;	/* possible next point */
    int		 count, i, istart, axis;
    double       asin();
    SppPointPtr	 poly;
    SppPointRec  lastPt;
    DDXPointRec  last;		/* last point on integer boundaries */
    int          lenCur;	/* used part of current dash */
    int          lenMax;	/* the desired length of this dash */
    int          iDash = 0;	/* index of current dash segment */
    int          nSegs = 0;	/* number of segments filled in */
    miDashedArcPtr pDashed;
    int          which;		/* EVEN_DASH or ODD_DASH */
    int          iphase;	/* 0 = even, 1 = odd */
    int          npts,		/* number of points used so far */
                 nalloced;	/* number of points allocated so far */
    int          a1;		/* angle1 for this arc */

    if (!(pDashed = (miDashedArcPtr) Xalloc((isDoubleDash ? 2 : 1) *
					    sizeof(miDashedArcRec))))
	return( NULL );		/* hosed */

    for ( ; nArcs > 0; nArcs--, pArc++, nSegs++)
    {
    	/* Throw out multiples of 360 degrees. */
	if (pArc->angle2 > FULLCIRCLE)
	    pArc->angle2 = FULLCIRCLE;
	else if (pArc->angle2 < -FULLCIRCLE)
	    pArc->angle2 = -FULLCIRCLE;

	/* The spec says that positive angles indicate counterclockwise motion.
	 * Given our coordinate system (with 0,0 in the upper left corner), 
	 * the screen appears flipped in Y.  The easiest fix is to negate the
	 * angles given */
	i = - (a1 = pArc->angle1);

	if(i < 0)
	{
	    while (i < -FULLCIRCLE)
		i += FULLCIRCLE;
	}
	else
	{
	    while(i > FULLCIRCLE)
		i -= FULLCIRCLE;
	}
	st = (double ) i;
	st *= ((double)M_PI) / (64 * 180); /* to degrees, then to rads */
	
	i = -pArc->angle2;
	/* If it's more than one full rotation, make it exactly 1 rotation */
	/* hey...it already is! */
	et = (double) i;
	et *= ((double)M_PI) / (64 * 180); /* to degrees, then to rads */
	
	/* Try to get a delta theta that is within 1/2 pixel.  Then adjust it
	 * so that it divides evenly into the total.
	 * I'm just using cdt 'cause I'm lazy.
	 */
	cdt = max(pArc->width, pArc->height)/2.0;
	if(cdt <= 0)
	    return 0;
	dt = asin( ((double) 1) / cdt ); /* minimum step necessary */
	count = et/dt;
	count = abs(count) + 1;
	dt = et/count;	
	count++;
	
	cdt = 2 * cos(dt);
	/* note this insists on arc compression */
	poly = (SppPointPtr) Xalloc((1+(nalloced = 3)) *
				    sizeof(SppPointRec));
	
	xc = pArc->width/2.0;		/* store half width and half height */
	yc = pArc->height/2.0;
	axis = (xc >= yc) ? X_AXIS : Y_AXIS;
	
	x0 = xc * cos(st);
	y0 = yc * sin(st);
	x1 = xc * cos(st + dt);
	y1 = yc * sin(st + dt);
	xc += pArc->x;		/* by adding initial point, these become */
	yc += pArc->y;		/* the center point */
	
	poly[1].x = (xc + x0);
	poly[1].y = (yc + y0);
	last.x = ROUNDTOINT( poly[2].x = (xc + x1) );
	last.y = ROUNDTOINT( poly[2].y = (yc + y1) );
	npts = 3;		/* got 2 pts so far */
	
	/* Handle dash offset if necessary.  May be retained from before. */
	if (nSegs > 0)
	{			/* we've already generated at least 1 arc */
	    if (ROUNDTOINT(xt) !=
		ROUNDTOINT(poly[1].x) ||
		ROUNDTOINT(yt) !=
		ROUNDTOINT(poly[1].y))
	    {			/* get next dash position */
		lenCur = dashOffset;
		which = EVEN_DASH;
		while (lenCur > pDash[iDash])
		{
		    lenCur -= pDash[iDash];
		    iDash++;
		    if (iDash >= nDashes)
			iDash = 0;
		    which = ~which;
		}
		lenMax = pDash[iDash];
	    }			/* otherwise retain old dash position */
	} else {		/* first segment, so restart dashes */
	    lenCur = dashOffset;
	    which = EVEN_DASH;
	    while (lenCur > pDash[iDash])
	    {
		lenCur -= pDash[iDash];
		iDash++;
		if (iDash >= nDashes)
		    iDash = 0;
		which = ~which;
	    }
	    lenMax = pDash[iDash];
	}			/* now dashes are set to correct offset */
	
	for (iphase = 0; iphase < (isDoubleDash ? 2 : 1); iphase++)
	{
	    pDashed[iphase].ndashes = pDashed[iphase].njoins =
		pDashed[iphase].ncaps = 0;
	    pDashed[iphase].dashes = (miArcDashPtr) NULL;
	    pDashed[iphase].joins  = (miArcJoinPtr) NULL;
	    pDashed[iphase].caps   = (miArcCapPtr)  NULL;
	}
	lenCur++;		/* cause we a'ready did x1, y1..right? */
	
	for(istart = 0, i = 2; i < count; i++)
	{
	    x2 = cdt * x1 - x0;
	    y2 = cdt * y1 - y0;
	    
	    lenCur++;
	    if (lenCur >= lenMax) /* phase slip here like in line code? XXX */
	    {
		lastPt = poly[npts - 1];
		if (which == EVEN_DASH)
		    iphase = 0;
	        else if (isDoubleDash)
		    iphase = 1;
		else		/* odd_dash but style = on-off-dashed */
		{
		    iphase = 2;
		    Xfree((pointer) poly); /* XXX dont generate this!! */
		}
		if (iphase < 2)
		{
		    if ((pDashed[iphase].ndashes) % REALLOC_STEP == 0)
			pDashed[iphase].dashes = (miArcDashPtr)
			    Xrealloc((pointer) pDashed[iphase].dashes,
				     (pDashed[iphase].ndashes+REALLOC_STEP) *
				     sizeof(miArcDashRec));
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc =
			*pArc;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc.angle2
			= a1 - dt * i * 180 * 64 / M_PI -
			    pArc->angle1;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].pts = poly;
		    pDashed[iphase].dashes[pDashed[iphase].ndashes].npts =
			npts;
		    pDashed[iphase].ndashes++;
		}
		pArc->angle1 = a1 -
		    dt * 180 * 64 * i / M_PI; /* XXX - ack! */
		npts = 2;
		/* next segment starts where this one ended */
		if (!(poly = (SppPointPtr)
		      Xalloc(((1+(nalloced = 1 + REALLOC_STEP)) *
			      sizeof(SppPointRec)))))
		    return ( NULL );
		poly[1] = lastPt;
		istart = i;	/* for next arc segment collection */
		which = ~which;
		iDash++;
		if (iDash >= nDashes)
		    iDash = 0;
		lenMax = pDash[iDash];
		lenCur = 0;
	    }
	    
	    xt = xc + x2;
	    yt = yc + y2;
	    if (((axis == X_AXIS) ?
		 (ROUNDTOINT(yt) != last.y) :
		 (ROUNDTOINT(xt) != last.x)) ||
		i > count - 3)	/* insure 2 at the end */
	    {
		/* allocate more space if we are about to need it */
		if (npts >= nalloced)
		    poly = (SppPointPtr)
			Xrealloc((pointer) poly,
				 ((1+(nalloced = npts + REALLOC_STEP)) *
				  sizeof(SppPointRec)));
		/* check if we just switched direction in the minor axis */
		if (npts >= 3)
		{
		    if (((poly[npts - 2].y - poly[npts - 1].y > 0.0) ?
			 (yt - poly[npts - 1].y > 0.0) :
			 (poly[npts - 1].y - yt > 0.0)) ||
			((poly[npts - 2].x - poly[npts - 1].x > 0.0) ?
			 (xt - poly[npts - 1].x > 0.0) :
			 (poly[npts - 1].x - xt > 0.0)))
		    {		/* axis swap (explained in miGetArcPts) */
			poly[npts].x = xc + x1;
			poly[npts].y = yc + y1;
			npts++;
			if (npts >= nalloced)
			    poly = (SppPointPtr)
				Xrealloc((pointer) poly,
					 ((1+(nalloced = npts + REALLOC_STEP))
					  *sizeof(SppPointRec)));
		    }
		}
		last.x = ROUNDTOINT( poly[npts].x = xt );
		last.y = ROUNDTOINT( poly[npts].y = yt );
		npts++;
	    }
	    
	    x0 = x1; y0 = y1;
	    x1 = x2; y1 = y2;
	}
	count = i = npts;
	/* adjust the last point */
	if (abs(pArc->angle2) >= FULLCIRCLE)
	    poly[i-1] = poly[1];
	else {
	    poly[i-1].x = (cos(st + et) * pArc->width/2.0 + xc);
	    poly[i-1].y = (sin(st + et) * pArc->height/2.0 + yc);
	}

	/* put points generated for this arc into this dash segment */
	if (which == EVEN_DASH)
	    iphase = 0;
	else if (isDoubleDash)
	    iphase = 1;
	else		/* odd_dash but style = on-off-dashed */
	{
	    iphase = 2;
	    Xfree((pointer) poly);
	}
	if (iphase < 2)
	{
	    if ((pDashed[iphase].ndashes) % REALLOC_STEP == 0)
		pDashed[iphase].dashes = (miArcDashPtr)
		    Xrealloc((pointer) pDashed[iphase].dashes,
			     (pDashed[iphase].ndashes+REALLOC_STEP) *
			     sizeof(miArcDashRec));
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc =
		*pArc;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].arc.angle2
		= a1 + pArc->angle2 - pArc->angle1;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].pts = poly;
	    pDashed[iphase].dashes[pDashed[iphase].ndashes].npts =
		npts;
	    pDashed[iphase].ndashes++;
	}
    }
    
    return( pDashed );
}
