.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 1\fP\s-1

\s+1\fBAthena Widgets and The Intrinsics\fP\s-1
.sp 2
.nr H1 1
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 1 \- Athena Widgets and The \*(xI
.XE
The X Toolkit is two distict pieces, the Xt \*(xI and a widget set.  While
the \*(xI are a Consortium standard, there is no standard widget set.
The Athena widget set is a sample implementation of a widget set build
upon the \*(xI.  In the \*(tk, a widget is the combination of an X
window or subwindow and its associated input and output semantics.
The Athena widgets provide the base functionality necessary to build 
a wide variety of application environments.  Because the \*(xI provide
the same basic functionality to all widget sets it may be possible to
use widgets from the Athena widget set with other widget sets based 
upon the \*(xI.  Since widget sets may also implement private protocols
all functionality may not be avalible when mixing and matching widget sets.
For information about the \*(xI, see the \fI\*(xT\fP.
.LP
The Athena widget set is a library package layered on top of the \*(xI
and Xlib.  This layer extends the basic abstractions provided by X
and provides the next layer of functionality primarily by supplying
a cohesive set of sample widgets.
.LP
To the extent possible, the \*(xI are policy free.
The application environment and widget set, not the \*(xI, define,
implement, and enforce:
.IP \(bu 5
Policy
.IP \(bu 5
Consistency
.IP \(bu 5
Style 
.LP
Each individual widget implementation defines its own policy.
The \*(tk design allows for, but does not necessarily encourage, 
the free mixing of radically differing widget implementations.
.NH 2
Introduction to the \*(tk 
.LP
.XS
\*(SN Introduction to the \*(tk
.XE
The \*(tk provides tools that simplify the design of
application user interfaces in the X Window System programming environment.
It assists application programmers by providing a set of common
underlying user-interface functions.  It also lets widget programmers
modify existing widgets or add new widgets.  By using the \*(tk in
their applications, programmers can present a similar user interface across 
applications to all workstation users.
.LP
The \*(tk consists of:
.IP \(bu 5
A set of \*(xI functions for building widgets
.IP \(bu 5
An architectural model for constructing widgets 
.IP \(bu 5
A widget set for application programming
.LP
While the majority of the \*(xI functions are intended 
for the widget programmer,
a subset of the \*(xI functions are to be used by application programmers
(see  \fI\*(xT\fP).
The architectural model lets the widget programmer design new widgets
by using the \*(xI and by combining other widgets.
The application interface layers built on top of the \*(tk include a
coordinated set of widgets and composition policies.
Some of these widgets and policies are specific to an application domain,
and others are common across a number of application domains.
.LP
The \*(tk also can implement one or more application interface layers to:
.IP \(bu 5
Verify the toolkit architecture
.IP \(bu 5
Provide a base set of widgets and composition policies that
can be incorporated in other application interface layers
.IP \(bu 5
Make the \*(tk immediately usable by those application 
programmers who find that a supplied application interface layer
meets their needs
.LP
The remainder of this chapter discusses the \*(tk and Athena widget set:
.IP \(bu 5
Terminology
.IP \(bu 5
Model
.IP \(bu 5
Design principles and philosophy
.IP \(bu 5
Conventions used in this manual
.LE
.NH 2 
Terminology
.LP
.XS
\*(SN Terminology
.XE
.LP
In addition to the terms already defined for X programming (see \fI\*(xL\fP),
the following terms are specific to the \*(xI and Athena widget set
and used throughout this book. 
.LP
\fBApplication programmer\fP
.IN "Application programmer" "" "@DEF@"
.IP
A programmer who uses the \*(tk to produce an application user interface.
.LP
.PN Child
.IP
A widget that is contained within another ("parent") widget.
.LP
\fBClass\fP
.IN "Class" "" "@DEF@"
.IP
The general group to which a specific object belongs.
.LP
\fBClient\fP
.IN "Client" "" "@DEF@"
.IP
A function that uses a widget in an application or for composing
other widgets.
.LP
.PN "Full\ name"
.IP
The name of a widget instance appended to the full name of its parent.
.LP
\fBInstance\fP
.IN "Instance" "" "@DEF@"
.IP
A specific widget object as opposed to a general widget class.
.LP
\fBMethod\fP
.IN "Method" "" "@DEF@"
.IP
The functions or procedures that a widget class implements.
.LP
\fBName\fP
.IN "Name" "" "@DEF@"
.IP
The name that is specific to an instance of a widget for a given client.
.LP
\fBObject\fP
.IN "Object" "" "@DEF@"
.IP
A software data abstraction consisting of private data and private and public
functions that operate on the private data.
Users of the abstraction can interact with the object only through calls
to the object's public functions.
In the \*(tk,
some of the object's public functions are called directly by the application,
while others are called indirectly when the application calls the common
\*(xI functions.
In general, if a function is common to all widgets,
an application uses a single \*(xI function to invoke the function for all
types of widgets.
If a function is unique to a single widget type,
the widget exports the function.
.LP
.PN Parent
.IP
A widget that contains at least one other ("child") widget.
A parent widget is also known as a composite widget.
.LP
\fBResource\fP
.IN "Resource" "" "@DEF@"
.IP
A named piece of data in a widget that can be set by a client,
by an application, or by user defaults.
.LP
.PN Superclass
.IP
A larger class of which a specific class is a member.
All members of a class are also members of the superclass.
.LP
\fBUser\fP
.IN "User" "" "@DEF@"
.IP
A person interacting with a workstation.
.LP
\fBWidget\fP
.IN "Widget" "" "@DEF@"
.IP
An object providing a user-interface abstraction (for example, a Scrollbar
widget).
.LP
\fBWidget class\fP
.IN "Widget class" "" "@DEF@"
.IP
The general group to which a specific widget belongs,
otherwise known as the type of the widget.
.LP
\fBWidget programmer\fP
.IN "Widget programmer" "" "@DEF@"
.IP
A programmer who adds new widgets to the \*(tk.
.NH 2
Underlying Model
.LP
.XS
\*(SN Underlying Model
.XE
The underlying architectural model is based on the following premises:
.KS
.IP "Widgets are X windows"
.IP
Every user-interface widget is associated with an X window.
The X window ID for a widget is readily available from the widget ID.
Standard Xlib calls can be used by widgets for many of their input and
output operations.
.KE
.KS
.IP "Information hiding"
.IP
The data for every widget is private to the widget and its subclasses.
That is, the data is neither directly accessible 
nor visible outside of the module implementing the widget.
All program interaction with the widget is performed by a set of operations
(methods) that are defined for the widget.
.KE
.KS
.IP "Widget semantics and widget layout geometry"
.IP
Widget semantics are clearly separated from widget layout
geometry.
Widgets are concerned with implementing specific user-interface
semantics.
They have little control over issues such as their size or
placement relative to other widget peers.
Mechanisms are provided for associating geometric managers with widgets
and for widgets to make suggestions about their own geometry.
.KE
.NH 2 
Design Principles and Philosophy
.LP
.XS
\*(SN Design Principles and Philosophy
.XE
The \*(tk follows two design principles throughout,
which cover languages and language bindings as well as widget IDs.
.NH 3
Languages and Language Bindings
.LP
The \*(tk facilitates access from objective languages.
However, the \*(tk library is conveniently usable by
application programs written in nonobjective languages.
Procedural interface guidelines are required when the
\*(tk is used with nonobjective languages.
.LP
The guidelines for the procedural interfaces are:
.IP \(bu 5
Strings are passed as null-terminated character arrays.
.IP \(bu 5
Most other arrays are passed using two parameters: a size and a pointer to 
the first element.
.IP \(bu 5
Most numeric arguments are passed by value.
.IP \(bu 5
Structures as arguments are avoided, 
unless a method for building them is provided for languages without pointers.
Pointers embedded in structures are allowed, 
but they should be avoided if an equivalent alternative is available.
.IP \(bu 5
Pointers are not recommended as return arguments, unless they will never
have to be dereferenced by the caller.
If they need to be dereferenced, 
the caller should allocate storage and pass the address to the procedure 
to fill in.
.IP \(bu 5
Procedures can be passed as parameters.
.IP \(bu 5
The ownership of dynamically allocated storage is determined on a 
case-by-case basis.
The application is also permitted to replace the standard
memory allocation and freeing routines used by the library at build time.
.NH 3
Widget IDs
.LP
All references to widgets use a unique identifier that is known as the widget ID.
The widget ID is returned to the client by the
.PN XtCreateWidget
function.
From an application programmer's perspective,
a widget ID is an opaque data type;
no particular interpretation can be assigned to it.
Given a widget ID, 
you can retrieve the corresponding X window ID, the
.PN Display
and 
.PN Screen
structures, and other information by using \*(xI functions.
.LP
From a widget programmer's perspective,
the widget ID actually is a pointer to a data structure 
known as the widget instance record.
Several parts of the data structure are common to all widget types,
while other parts are unique to a particular widget type.
The widget's private data that is associated with a particular widget instance
normally is included directly in the widget instance record.
.NH 2
Conventions Used in this Manual
.IP \(bu 5
All resources avalible to the widgets are listed with each widget.  Many
of these are avalible to more than one widget class due to the object
oriented nature of the \*(xI.  The new resources for each widget are
listed in bold text, and the inherited resources are listed in plain text.
.IP \(bu 5
Global symbols are printed in \fBbold\fP and can be function names,
symbols defined in include files, or structure names.  Aguments are
printed in italics.
.IP \(bu 5
Each function is introduced by a general discussion that distinguishes
it from other functions.  The function declaration itself follows, and
each argument is specifically explained.  General discussion of the
function, if any is required, follows the arguments.  Where
applicable, the last paragraph of the explanation lists the return values
of the function.
.IP \(bu 5
To eliminate any ambiguity between those arguments that you pass and
those thata function returns to you, the explanations for all
arguments that you pass start with the word \fIspecifies\fP or, in the
case of multiple arguments, the word \fIspecify\fP. The explanations
for all arguments that are returned to you start with the word
\fIreturns\fP or, in the case of multiple arguments, the word
\fIreturn\fP.  The explanations for all arguments that you can pass
and are returned start with the words \fIspecifies and returns\fP.
.IP \(bu 5
Any pointer to a structure that is used to return a value is
designated as such by the \fI_return\fP suffix as part of its name.
All other pointers passed to these functions are used for reading
only.  A few arguments use pointers to structures that are used for
both input and output and are indicated by using the \fI_in_out\fP
suffix.
