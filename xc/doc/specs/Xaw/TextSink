.LP
.NH 2
Ascii Sink Object
.LP
.XS
\*(SN AsciiSink Object
.XE
.IN "AsciiSink object" "" "@DEF@"
.LP
.Ds 0
.TA 2.0i
.ta 2.0i
Header file	AsciiSink.h
Class		asciiSinkObjectClass
Class Name	AsciiSink
.sp 1
.LP
The AsciiSink object is used by a text widget to render the text.  It
will display all Latin1 Characters in an 8 bit font, Tab and
Carriage Return.  The name may be a bit misleading, but is left this
way for compatability.  This object also reports the text window
metrics to the text widgets.
.De
.sp 1
.LP
.IN "AsciiSink object" "resources"
.ps 9
.nr PS 9
.vs 11
.nr VS 11
.TS H
lw(1.5i) lw(1i) lw(1i) lw(2i).
_
.sp 3p
.TB
Name	Class	Type	Default Value
.sp 3p
_
.TH
.R
.sp 3p
background	Background	Pixel	XtDefaultBackground
destroyCallback	Callback	XtCallbackList	NULL
displayNonprinting	Output	Boolean	True
echo	Output	Boolean	True
font	Font	XFontStruct*	XtDefaultFont
foreground	Foreground	Pixel	XtDefaultForground
.sp 3p
_
.TE
.ps 11
.nr PS 11
.vs 13
.nr VS 13
.IP background 1.5i
The background color of the text to display in the text widget.  I have
added this resource to the AsciiSink instead of just stealing if from the
Text widget for completeness.
.IP destroyCallback 1.5i
All callback functions on this list are called when this object is destroyed.
.IP \fBdisplayNonprinting\fP 1.5i
If \fBtrue\fP all non-printable characters will be displayed as the
string \fI^@\fP.  If \fBfalse\fP blank space will be left where a non
printable character exists in the text buffer.
.IP \fBecho\fP 1.5i
Whether or not to echo characters to the screen.  You can still edit
the buffer, but nothing is displayed.  This mode can be useful for
entering passwords and other sensitive information.  
.IP font 1.5i
The font for rendering all text.  This font must be a character cell,
(fixed width) font.
.IP foreground 1.5i
The foreground color of all text displayed.
.LP
.NH 2
TextSink Object
.LP
.XS
\*(SN TextSink Object
.XE
.IN "TextSink object" "" "@DEF@"
.LP
.Ds 0
.TA 2.0i
.ta 2.0i
Header file	TextSink.h
Class		textSinkObjectClass
Class Name	TextSink
.sp 1
.LP
The TextSink object is the root object for all Text Sinks.  Any new text
sink widgets should be subclasses of the TextSink Object.  The
TextSink Class contains all methods the Text widget expects a Text
sink to export.  Since all Text sinks will have some resources in
common the TextSink defines a few new resources. 
.De
.sp 1
.LP
.IN "AsciiSink object" "resources"
.ps 9
.nr PS 9
.vs 11
.nr VS 11
.TS H
lw(1.5i) lw(1i) lw(1i) lw(2i).
_
.sp 3p
.TB
Name	Class	Type	Default Value
.sp 3p
_
.TH
.R
.sp 3p
background	Background	Pixel	XtDefaultBackground
destroyCallback	Callback	XtCallbackList	NULL
font	Font	XFontStruct*	XtDefaultFont
foreground	Foreground	Pixel	XtDefaultForground
.sp 3p
_
.TE
.ps 11
.nr PS 11
.vs 13
.nr VS 13
.IP \fBbackground\fP 1.5i
One background color is provided in TextSink.
.IP destroyCallback 1.5i
All callback functions on this list are called when this object is destroyed.
.IP \fBfont\fP 1.5i
The font for rendering all text.  Although the current AsciiSink
requires character cell fonts new TextSinks need not have this
restriction.   This resource is included, as it is assumed that all
TextSinks will need at least one font.  Subclasses of the TextSink are
free to use this resource as they see fit.
.IP \fBforeground\fP 1.5i
One foreground color is provided in TextSink, as at least one will be
required.  
.NH 3
Subclassing the TextSink
.IN "TextSink object" "Subclassing" "@DEF@"
.LP
The only purpose of the TextSink Object is to be subclassed.  It
contains the minium set of class methods that all text sinks must have.
While all may be inherited, the
direct descendant of TextSink \fBmust specify\fP some of them as TextSink does
contain enough smarts to be a valid text sink by itself.  Do not try to use
the TextSink as a valid sink for the Text widget, it is not intended
to be used as a sink by itself and bad things will probabally happen.
.ps 9
.nr PS 9
.vs 11
.nr VS 11
.TS H
lw(1i) lw(1.5i) lw(2i) lw(1i).
_
.sp 3p
.TB
Function	Inherit with	Public Interface	must specify
.sp 3p
_
.TH
.R
.sp 3p
DisplayText	XtInheritDisplayText	XawTextSinkDisplayText	yes
InsertCursor	XtInheritInsertCursor	XawTextSinkInsertCursor	yes
ClearToBackground	XtInheritClearToBackground	XawTextSinkClearToBackground	no
FindPosition	XtInheritFindPosition	XawTextSinkFindPosition	yes
FindDistance	XtInheritFindDistance	XawTextSinkFindDistance	yes
Resolve	XtInheritResolve	XawTextSinkResolve	yes
MaxLines	XtInheritMaxLines	XawTextSinkMaxLines	no
MaxHeight	XtInheritMaxHeight	XawTextSinkMaxHeight	no
SetTabs	XtInheritSetTabs	XawTextSinkSetTabs	no
GetCursorBounds	XtInheritGetCursorBounds	XawTextSinkGetCursorBounds	yes
.sp 1
_
.TE
.ps 11
.nr PS 11
.vs 13
.nr VS 13
.NH 4
Displaying Text
.LP
To display a section of the text buffer contained in the text source
use the function \fIDisplayText\fP.

.IN "TextSink" "DisplayText" "@DEF@"
.FD 0
void DisplayText(\fIw\fP, \fIx\fP, \fIy\fP, \fIpos1\fP, \fIpos2\fP, \fIhighlight\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP, \fIy\fP;
.br
      XawTextPosition \fIpos1\fP, \fIpos2\fP;
.br
      Boolean \fIhighlight\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIx\fP 1i
Specifies the x location to start drawing the text.
.IP \fIy\fP 1i
Specifies the y location to start drawing text.
.IP \fIpos1\fP 1i
Specifies the location within the text source of the first character
to be printed.
.IP \fIpos2\fP 1i
Specifies the location within the text source of the last character
to be printed.
.IP \fIhighlight\fP 1i
If this is \fBtrue\fP then paint then paint this text region highlighted.
.LP
The text widget will only pass one line at a time to the text sink so this
function does not need to know how to line feed the text.  It is
acceptable for this function to just ignore Carrige Returns.  \fIx\fP
and \fIy\fP denote the upper left hand corner of the first character
to be displayed.  
.NH 4
Displaying the Text Cursor
.LP
The function that controls the display of the text cursor is
\fBInsertCursor\fP.  This function will be called whenever the text
widget desires to change the state of, or move the text cursor.  
.IN "TextSink" "InsertCursor" "@DEF@"
.FD 0
void InsertCursor(\fIw\fP, \fIx\fP, \fIy\fP, \fIstate\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP, \fIy\fP;
.br
      XawTextInsertState \fIstate\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIx\fP 1i
Specifies the x location of the cursor in Pixels.
.IP \fIy\fP 1i
Specifies the y location of the cursor in Pixels.
.IP \fIstate\fP 1i
Specifies the state of the cursor, may be one of \fBXawisOn\fP or
\fBXawisOff\fP.
.LP
\fIx\fP and \fIy\fP denote the upper left hand corner of the text cursor.
The current implementation of the Text widget turns the cursor off
before it performs any operations, and then turns it back on again
when it is through.  The behavior is horribly inefficient, and I hope
to have something better at some point.  If this is the case then this
function may need to be more clever than the current implementation
now requires.  Please keep this in mind when designing this function.
.NH 4
Clearing Portions of the Text window
.LP
To clear a portion of the Text window to its background color the Text
widget will call \fBClearToBackground\fP.  The TextSink object already
defines this function as calling XClearArea on the region passed.
This behavior will be used if you specify
\fBXtInheritClearToBackground\fP for this method.
.IN "TextSink" "ClearToBackground" "@DEF@"
.FD 0
void ClearToBackground(\fIw\fP, \fIx\fP, \fIy\fP, \fIwidth\fP, \fIheight\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP, \fIy\fP;
.br
      Dimension \fIwidth\fP, \fIheight\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIx\fP 1i
Specifies the x location, in pixels, of the Region to clear.
.IP \fIy\fP 1i
Specifies the y location, in pixels, of the Region to clear.
.IP \fIwidth\fP 1i
Specifies the width, in pixels, of the Region to clear.
.IP \fIheight\fP 1i
Specifies the height, in pixels, of the Region to clear.
.LP
\fIx\fP and \fIy\fP denote the upper left hand corner of region to clear.
.NH 4
Finding a Text Position Given Pixel Values
.LP
To find the text character position that will be rendered at a given x
location the text widget uses the function \fBFindPosition\fP.
.IN "TextSink" "FindPosition" "@DEF@"
.FD 0
void FindPosition(\fIw\fP, \fIfromPos\fP, \fIfromX\fP, \fIwidth\fP, \fIstopAtWordBreak\fP, \fIresPos\fP, \fIresWidth\fP, \fIresHeight\fP)
.br
      Widget \fIw\fP;
.br
      XawTextPosition \fIfromPos\fP;
.br
      int \fIfromX\fP, \fIwidth\fP;
.br
      Boolean \fIstopAtWordBreak\fP;
.br
      XawTextPosition \fI*resPos\fP;
.br
      int \fI*resWidth\fP, \fI*resHeight\fP;
.FN
.IP \fIw\fP 1.25i
Specifies the widget ID of the TextSink object.
.IP \fIfromPos\fP 1.25i
Specifies a reference position, usually the first character in this line.
This character is always to the left of the desired character location.
.IP \fIfromX\fP 1.25i
Specifies the distance that the left edge of \fIfromPos\fP is from the
left edge of the window.  This is the reference x location for the
reference position.
.IP \fIwidth\fP 1.25i
Specifies the distance, in pixels, from the reference position to the
desired character position.
.IP \fIstopAtWordBreak\fP 1.25i
If the position that we have specified is not on a word break and 
this value is \fBtrue\fP then return the word break closest to the new
character position, but between this position and the reference position.
.IP \fIresPos\fP 1.25i
\fI*resPos\fP will contain the character position that corresponds to the
location that we have specified, or the closest white space if
\fIstopAtWordBread\fP is \fBtrue\fP.
.IP \fIresWidth\fP 1.25i
\fI*resWidth\fP will contain the actual distance between \fIfromPos\fP
and \fI*resPos\fI.
.IP \fIresHeight\fP 1.25i
\fI*resHeight\fP will contain the maxium height of the text between
\fIfromPos\fP and \fI*resPos\fI.
.LP
This function need make no attempt to deal with line feeds.  The text
widget will only call it one line at a time.
.LP
.sp
Another means of finding a text position is provided by the \fBResolve\fP
functions
.IN "TextSink" "Resolve" "@DEF@"
.FD 0
void Resolve(\fIw\fP, \fIfromPos\fP, \fIfromX\fP, \fIwidth\fP, \fIresPos\fP)
.br
      Widget \fIw\fP;
.br
      XawTextPosition \fIfromPos\fP;
.br
      int \fIfromX\fP, \fIwidth\fP;
.br
      XawTextPosition \fI*resPos\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIfromPos\fP 1i
Specifies a reference position, usually the first character in this line.
This character is always to the left of the desired character location.
.IP \fIfromX\fP 1i
Specifies the distance that the left edge of \fIfromPos\fP is from the
left edge of the window.  This is the reference x location for the
reference position.
.IP \fIwidth\fP 1i
Specifies the distance, in pixels, from the reference position to the
desired character position.
.IP \fIresPos\fP 1i
\fI*resPos\fP will contain the character position that corresponds to the
location that we have specified, or the closest white space if
\fIstopAtWordBread\fP is \fBtrue\fP.
.LP
This function need make no attempt to deal with line feeds.  The text
widget will only call it one line at a time.  This is a more convient
interface to the \fBFindPosition\fP function, and provides a subset of the
functionality.
.NH 4
Finding the Distance Between two Text Positions
.LP
To find the distance in pixels between two text positions on the same
line use the function \fBFindDistance\fP.
.IN "TextSink" "FindDistance" "@DEF@"
.FD 0
void FindPosition(\fIw\fP, \fIfromPos\fP, \fIfromX\fP, \fItoPos\fP, \fIresWidth\fP, \fIresPos\fP, \fIresHeight\fP)
.br
      Widget \fIw\fP;
.br
      XawTextPosition \fIfromPos\fP, \fItoPos\fP;
.br
      int \fIfromX\fP;
.br
      XawTextPosition \fI*resPos\fP;
.br
      int \fI*resWidth\fP, \fI*resHeight\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIfromPos\fP 1i
Specifies the text buffer position, in characters, of the first position.
.IP \fIfromX\fP 1i
Specifies the distance that the left edge of \fIfromPos\fP is from the
left edge of the window.  This is the reference x location for the
reference position.
.IP \fItoPos\fP 1i
Specifies the text buffer position, in characters, of the second position.
.IP \fIresWidth\fP 1i
\fI*resWidth\fP will contain the actual distance between \fIfromPos\fP
and \fI*resPos\fI.
.IP \fIresPos\fP 1i
\fI*resPos\fP will contain the character position that corresponds to the
actual character position used for \fItoPos\fP in the calculations.  This
may be differnt than \fItoPos\fP, for example if \fIfromPos\fP and
\fItoPos\fP are on different lines in the file.
.IP \fIresHeight\fP 1i 
\fI*resHeight\fP will contain the maxium height of the text between
\fIfromPos\fP and \fI*resPos\fI.
.LP
This function need make no attempt to deal with line feeds.  The text
widget will only call it one line at a time.
.NH 4
Finding the Size of the Drawing area
.LP
To find the maximum number of characters lines that will fit into the
current Text widget use the function \fBMaxLines\fP.  The TextSink
already defines this function to compute the maximum number if lines by
using the height of \fBfont\fP.
.IN "TextSink" "MaxLines" "@DEF@"
.FD 0
int MaxLines(\fIw\fP, \fIheight\fP)
.br
      Widget \fIw\fP;
.br
      Dimension \fIheight\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIheight\fP 1i
Height of the current drawing area.
.LP
Returns the maximum number of lines that will fit in \fIheight\fP.
.LP
.sp
To find the height required for a give number of text lines use
the function \fBMaxHeight\fP.  The TextSink already defines this
function to compute the maximum height of the window by using the
height of \fBfont\fP. 
.IN "TextSink" "MaxHeight" "@DEF@"
.FD 0
int MaxLines(\fIw\fP, \fIlines\fP)
.br
      Widget \fIw\fP;
.br
      int \fIlines\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIheight\fP 1i
Height of the current drawing area.
.LP
Returns the height that will be taken up by the number of lines passed.
.NH 4
Setting the Tab Stops
.LP
To set the tabs stops for a text sink use the \fBSetTabs\fI
function.  The TextSink already defines this function to set the tab
x location in pixels to be the number of characters times the figure width
of \fBfont\fP.
.IN "TextSink" "SetTabs" "@DEF@"
.FD 0
void SetTabs(\fIw\fP, \fItab_count\fP, \fItabs\fP)
.br
      Widget \fIw\fP;
.br
      int \fItab_count\fP, \fI*tabs\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fItab_count\fP 1i
The number of tabs passed in \fItabs\fP.
.IP \fItabs\fP 1i
The position, in characters, of the tab stops.  
.LP
This function is responsible for the converting character positions passed
to it into whatever internal positions the TextSink uses for tab placement.
.NH 4
Getting the Text Cursor's Size and Location
.LP
To get the size and location of the text cursor use the
\fBGetCursorBounds\fP function.
.IN "TextSink" "GetCursorBounds" "@DEF@"
.FD 0
void GetCursorBounds(\fIw\fP, \fIrect\fP)
.br
Widget \fIw\fP;
.br
XRectangle \fI*rect\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the TextSink object.
.IP \fIrect\fP 1i
This must be a pointer to a valid XRectangle Structure.  It will
contain the locaion and size of the text cursor when this function returns.
.LP
\fIRect\fP is filled with the current size and location of the text cursor.
