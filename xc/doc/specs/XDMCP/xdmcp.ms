		  X Display Manager Control Protocol (XDMCP)

Copyright 1988 by the Massachusetts Institute of Technology

This document is for internal use by Member and Affiliate
organizations of the MIT X Consortium.  It may be redistributed
internally within such organizations, provided the above copyright
notice and this permission notice appear in all copies, but it is not
to be published and it is not to be redistributed externally.  MIT
makes no representations about the suitability for any purpose of the
information in this document.  It is provided "as is" without express
or implied warranty.  The information in this document is a
preliminary draft and therefore subject to change, and does not
represent an approved specification of the MIT X Consortium.



Abstract

Since the X Display Manager (xdm) may be used to manage remote displays (such
as X terminals), a protocol for requesting service over the network is needed.
Since it should have as little overhead as possible, the XDM Control Protocol
(also called XDMCP) is designed to use unreliable datagrams, a common
format among all packets, and a synchronous request-reply model to handle
sequencing and retransmission.



Packet Format

All XDMCP packets have the following information:

	    Length in   Field		description of field
	      Bytes     Type
	
		2	CARD16		version number
		2	CARD16		length of packet in bytes
		2	CARD16		opcode
		4	CARD32		session id
		2	CARD16		length of display name (j)
		j	STRING8		display name
		2	CARD16		length of auth name (k)
		k	STRING8		authorization protocol name
		2	CARD16		length of auth data (l)
		l	STRING8		authorization protocol data


The numeric fields are stored most-significant byte first and string fields
are not padded.  The fields are as follows:

    Version Number
	This specifies the version of XDMCP that generated this packet in
	case changes in this protocol are required.  Terminals and display
	Managers may choose to support older versions for compatibility.
	This field will initially be 1.

    Length of Packet in Bytes
	This specifies the total length of the packet in octets and should
	be equal to the size of the fixed-length header information (16 bytes
	in version 1) plus the lengths of the three string fields.  Packets
	that have too little or too much data should be ignored.

    Opcode
	This specifies what step of the protocol this packet represents and
	should contain one of the following values (encoding provided at the
	end):  BroadcastQuery, Query, Willing, Unwilling, Request, Accept,
	Decline, Manage, Refuse.

    Session ID
	This is used in the Accept, Manage, and Refuse packets as a check
	code for distinguishing this session from others in case of
	retransmissions.

    Length of Display Name in Bytes
	This specifies the length of the display name field.

    Display Name
	This specifies the name of display as would be used with -display
	command line arguments or the DISPLAY environment variable (under
	UNIX).  Terminals should always set this field; Display Managers
	should simply copy the field from the packet to which they are
	responding.

    Length of Authorization Protocol Name
	This specifies the length of the authorization protocol name field.
	
    Authorization Protocol Name
	This field identifies the protocol to be used in decoding the
	information in the Authorization Protocol Data field.  It is usually
	a string and its interpretation is up to the recipient of the packet.
	A registry of Protocol Names will be needed.

    Length of Authorization Protocol Data
	This field contains arbitrary data for use in authorizing a given
	connection.  The interpretation of this information is determined
	by the name of the protocol being used.  Secure protocols (such as
	Kerberos) may use encryption to provide mutual verification between
	the user and the Display Manager.  Unsecure protocols (such as
	MIT-MAGIC-COOKIE-1) may simply rely on a piece of shared information.
	

Packets should be checked to make sure that they satisfy the following
conditions:

    1.  They must contain valid opcodes.
    2.  The total length of the packet should equal the size of the fixed
	information (16 bytes) plus the lengths of the display name, 
	auth name, and auth data.
    3.  The authorization protocol name should be recognized.  A zero-length
	name means that no authorization information is provided.  Recipients
	may choose whether or not they will accept such packets.
    4.  The opcode should be expected (a finite state diagram is given
	in a later section).
    5.  If the packet is of type Manage or Refuse, the session id should
	match the value sent in the preceeding Accept packet.




Protocol

Each of the opcodes is described below.  Since a given packet type is only ever
generated by the Terminal or by the Display Manager, each of the opcodes
indicates the direction in which it is sent.

    BroadcastQuery
    Query
	Terminal-to-Manager
	Fields:
	    Session ID
		This field is not used and should be set to zero (0).

	    Auth Name
	    Auth Data
		These fields may be used by the Display Manager to verify the
		identity of the Terminal.  This would be used in environments
		that wish to control access to a given terminal or system.
		This could be done by sending a message that was encrypted with
		the Display Manager's private key.
	Semantics:
	    A Query packet is sent from the Terminal to a specific host
	    to ask if that host is willing to provide xdm services to this
	    terminal.  The host should respond with Willing if it is willing
	    to service the Terminal or Unwilling if it is not.

	    A BroadcastQuery packet is similar to the Query packet except
	    that it is sent to all hosts on the network.  However, unlike
	    Query requests, hosts that are not willing to service the Terminal
	    should simply ignore BroadcastQuery requests.
	Valid Responses:
	    Willing, Unwilling
	Problems/Solutions:
		Problem:
			Not all managers receive the BroadcastQuery.
		Indication:
			none if BroadcastQuery was broadcast,
			else failure to receive Willing.
		Solution:
  			repeatedly send BroadcastQuery while waiting
			for user to choose a host.

    Willing
	Manager-to-Terminal
	Fields:
	    Session ID
		This field is not used and should be set to zero (0).
	    Auth Name
	    Auth Data
		These fields may be used by the Terminal to verify that the
		Display Manager was able to decode the authorization
		information sent in the Query or BroadcastQuery packet.  This
		might be done by returning the previous auth data permuted
		in some known way (such as by adding 1 and reencrypting with
		the Terminal's key which it could have been sent encrypted in
		the Query).
	Semantics:
	    A Willing packet is sent by Display Managers that may service 
	    connections from this Terminal.  It is sent in response to either
	    a Query or a BroadcastQuery but does not imply a commitment to 
	    provide service (it may later decide that it as accepted enough
	    connections already).
	Problems/Solutions:
	    Problem:
		    Willing not received by the terminal.
	    Indication:
		    none if Query was broadcast, else failure to
		    receive Willing.
	    Solution:  
		    The terminal should continue to send Query
		    messages until a response is received.

    Unwilling
	Manager-to-Terminal
	Fields:
	    Session ID
		This field is not used and should be set to zero (0).
	    Auth Name
	    Auth Data
		These fields should be set in the same manner as those in
		a Willing packet.
	Semantics:
	    An Unwilling packet is sent by Display Managers in response to
	    direct Query requests (as opposed to general BroadcastQuery
	    requests) if the Display Manager will not accept requests for 
	    management.  This is typically sent by Display Managers that wish
	    to only service particular Terminals or which handle a limited 
	    number of Terminals at once.
	Problems/Solutions:
	    Problem:
		    Unwilling not received by the terminal.
	    Indication:
		    Terminal fails to receive Unwilling.
	    Solution:
		    The terminal should continue to
		    send Query messages until a response is received.

    Request
	Terminal-to-Manager
	Fields:
	    Session ID
		This field is not used and should be set to zero (0).
	    Auth Name
	    Auth Data
		These fields should be set in the same manner as those in a
		Query packet.
	Semantics:
	    A Request packet is sent by a Terminal to a specific host to
	    request a session id in preparation for a establishing a 
	    connection.  If the Display Manager is willing to service a 
	    connection to this Terminal, it should return an Accept packet 
	    with a valid session id and should be ready for subsequent
	    Manage requests.  Otherwise, it should return a Decline packet.
	Valid Responses:
	    Accept, Decline
	Problems/Solutions:
	    Problem:
		    Request not received by manager.
	    Indication:
		    Terminal timeout waiting for response.
	    Solution:
		    Terminal resends Request message.

	    Problem:
		    Message received out of order by manager.
	    Indication:
		    none
	    Solution:
		    Each time a Request is sent, the manager sends the
		    session ID associated with the next session in the
		    Acknowledge.  If that next session is not yet
		    started, the manager will simply resend with the same
		    session ID.  If the session is in progress, the
		    manager will reply with a new session ID; in this
		    case, the Acknowledge will be discarded by the
		    terminal.


    Accept
	Manager-to-Terminal
	Fields:
	    Session ID
		This field should contain a non-zero number that is to be used
		as an identifier for this session.  The Display Manager should
		make an attempt to not reuse identifiers in a repeatable way.
	    Auth Name
	    Auth Data
		These fields should be set in response to the Request packet
		in the same manner the fields are set in a Willing packet.
	Semantics:
	    An Accept packet is sent by a Display Manager in response to a 
	    Request packet if the Display Manager is willing to establish a
	    connection for the Terminal.  The session id is used to identify
	    this connection from any preceeding ones and will be used by the
	    Terminal in its subsequent Manage packet.
	Problems/Solutions:
	    Problem:
		    Accept/Decline not received by terminal.
	    Indication:
		    Terminal timeout waiting for response to Request.
	    Solution:
		    Terminal resends Request message.
    
	    Problem:
		    Message received out of order by terminal.
	    Indication:
		    Terminal receives Accept after Manage has been sent.
	    Solution:
		    Terminal discards Accept messages after
		    it has sent a Manage message.

    Decline
	Manager-to-Terminal
	Fields:
	    Session ID
		This field is not used and should be set to zero (0).
	    Auth Name
	    Auth Data
		These fields should be set in the same manner as those in
		an Accept packet.
	Semantics:
	    A Decline packet is sent by a Display Manager in response to a
	    Rquest packet if the Display Manager is unwilling to establish
	    a connection for the Terminal.  This is allowed even if the
	    Display Manager had responded Willing to a previous Query (as 
	    might be the case if the Display Managers had a limit to the 
	    number of Terminals it would serve).
	Problems/Solutions:
	    same as for Accept.

    Manage
	Terminal-to-Manager
	Fields:
	    Session ID
		This field should contain the non-zero session id returned
		in the Accept packet.
	    Auth Name
	    Auth Data
		These fields should contain information that the Display
		Manager will need to open the initial X connection.  Secure
		protocols may use encryption as described for the Query packet.
	Semantics:
	    A Manage packet is sent by a Terminal to ask the Display Manager 
	    to begin a session on the Terminal.  If the session id is correct
	    the Display Manager should open a X connection, otherwise it 
	    should respond with a Refuse packet.
	Valid Responses:
	    X connection with correct auth info, Refuse
	Problems/Solutions:
	    Problem:
		    Manage not received by manager.
	    Indication:
		    Terminal timeout waiting for XOpenDisplay.
	    Solution:
		    Terminal resends Manage message.

	    Problem:
		    Manage received out of order by manager.
	    Indication:
		    session already in progress.
	    Solution:
		    Refuse message is sent.
	    Indication:
		    Session ID doesn't match next session ID
	    Solution:
		    Refuse message is sent.

    Refuse
	Manager-to-Terminal
	Fields:
	    Session ID
		This field should be set the invalid session id received
		in the Manage packet.
	    Auth Name
	    Auth Data
		These fields should be set to the authorization information
		provided in the Manage packet.
	Semantics:
	    A Refuse packet is sent by a Display Manager in response to 
	    problems establishing a connection.  The Terminal should assume
	    that it received an old Accept packet and should resend its
	    Request packet.
	Problems/Solutions:
	    Problem:
		    Error message is lost.
	    Indication:
		    terminal times out waiting for OpenDisplay/Error.
	    Solution:
		    terminal resends Manage message.


When the session is over, the initial connection with the display (the
one which ack's the manage packet) will be closed.  At this point,
all other display connections should be closed and the terminal
can request another session.

These state diagrams are designed to cover all actions of both
the terminal and the manager.

Terminal:

	[start]:
		user-requested connect to some host -> [broadcast]
		user-requested connedt to one host -> [query]
	
	[broadcast]:
		Send BroadcastQuery packet
 		-> [collect-broadcast-query]
	
	[collect-broadcast]:
		receive Willing -> [update-broadcast-willing]
		user-requested connect to one host -> [start-connection]
		receive other -> [collect-broadcast]
		timeout -> [broadcast]
		
	[update-broadcast-willing]:
		Add new host to host-list.
		Display host-list.
		-> [collect-broadcast]
	
	[query]:
		Send Query packet
		-> [collect-query]
	
	[collect-query]:
		receive Willing -> [start-connection]
		receive Unwilling -> [stop-connection]
		receive other -> [collect-query]
		timeout -> [query]
	
	[start-connection]:
		Send Request packet
		-> [await-request-response]
	
	[await-request-response]:
		receive Accept -> [manage]
		receive Decline -> [stop-connection]
		timeout -> [start-connection]
	
	[manage]:
		Save session ID
		Close all display connections
		Send Manage packet with session ID
		-> [await-manage-response]
	
	[await-manage-response]:
		receive XOpenDisplay: -> [run-session]
		receive Refuse with matching session ID: -> [start-connection]
		timeout -> [manage]
	
	[stop-connection]:
		Display cause of termination
		-> [start]
	
	[run-session]:
		await close of first display connection
		-> [reset-terminal]
	
	[reset-terminal]:
		close all display connections
		-> [start]
	
Manager:

	[idle]:
		receive BroadcaseQuery -> [broadcast-respond]
		receive Query -> [query-respond]
		receive Request -> [request-respond]
		receive Manage -> [manage]
		-> [idle]
	
	[broadcast-respond]:
		if willing to manage -> [send-willing]
		-> [idle]
	
	[query-respond]:
		if willing to manage -> [send-willing]
		-> [send-unwilling]
	
	[send-willing]:
		Send Willing packet
		-> [idle]
	
	[send-unwilling]:
		Send Unwilling packet
		-> [idle]
	
	[request-respond]:
		if acceptable-to-manage -> [accept-session]
		-> [decline-session]
	
	[accept-session]:
		Generate session ID.  Save session ID/display name somewhere
		Send Accept packet
 		-> [idle]
		
	[decline-session]:
		Send Decline packet
		-> [idle]
	
	[manage]:
		If session ID matches saved session ID -> [run-session]
		-> [refuse]
	
	[refuse]:
		Send Refuse packet
		-> [idle]
	
	[run-session]:
		Terminate any session in progress
		open display succeeds -> [session]
		-> [refuse]
	
	[session]:
		Start a new session
		XCloseDisplay
		-> [idle]
	
Here are some sample problems and the method used in the protocol to
overcome them.

Problem:
	A Query packet is lost in the network.
Recognised by:
	Terminal doesn't receive response back from Manager
Solution:
	Terminal resends packet.  As the Manager doesn't care
	how many Query packets it receives, and has no state
	change associated with them this will cause no additional
	problems.

Problem:
	An Accept packet is delayed in the network.
Recognised by:
	Terminal times-out waiting for packet response,
	sends another Request and finally receives the first
	acknowledge.
Solution:
	Manager receives two request packets.  As no session is
	currently in progress, the same session ID will be sent in
	both cases.  Terminal receives at least one packet.

Problem:
	Manage packet is lost in the network.
Recognised by:
	Terminal times-out waiting for Refuse/XOpenDisplay.
Solution:
	Terminal resends Manage request using the same session ID.
	This session ID will still match the expected value in
	the Manager.
	
Problem:
	Manager receives a delayed Manage packet
Recognised by:
	Session ID in packet does not match expected value, or
	no Request has been seen from the Terminal
Solution:
	Manager sends a Refuse packet with the invalid
	Session ID.  Terminal receives this packet and
	discards it.
					
Problem:
	Manager receives an old Request packet while a session
	is in progress.
Recognised by:
	Terminal receives an Accept/Decline message while the session is
	still in progress (i.e. while the priviledged connection
	is still open).
Solution:
	Manager sends Accept/Decline message.  Terminal receives
	it and discards it if the session is in progress.

Problem:
	Terminal is turned off and back on.
Recognised by:
	Terminal initiates management again.
Solution:
	Terminal negotiates for a new session, sending Request,
	receiving Accept, sending Manage.  Manager kills any
	existing session at this point, and starts a new session.

This protocol is designed to satisfy the following constraints:

	Any message sent must be acknowledged in order to guarantee
	receipt.  This is satisfied in the Manage case by receipt
	of the XOpenDisplay command.  Sequence problems are solved
	by insisting that the session ID sent in the Acknowledge
	message is returned with the Manage message.  While waiting
	for a user to choose the desired host, making the Terminal
	repeatedly send out Query messages will cause any
	machines which suddenly start/stop responding to be
	reflected in the menu.  In this way, the user can
	wait for a machine to come online before choosing a
	session.

	Terminals may be turned off at random.  Any existing session
	running on a terminal which has been turned off must be
	identifiable.  This is made possible by the sequence
	Request/Acknowledge/Manage.  If this sequence is sent, any
	existing session is terminated immediately and a new session
	started.  There is the problem (at least with TCP) that
	connections may not be closed when the terminal is turned
	off.  The manager could ameliorate this for local connections
	by periodically XSync'ing on its own connection, and terminating
	the session if its own connection ever closes.

	Terminals should not be required to retain permanent state for
	purposes of the control protocol.  Once solution to sequencing
	errors would be to use monotonically-increasing message identifiers
	to allow both sides to ignore messages which arrive out-of-sequence.
	For this to work, terminals would at a minimum have to increment
	a stable "crash count" each time they are powered on, and use that
	number as part of a larger sequence number.  But if terminals
	cannot retain permanent state this cannot work.  Instead, the
	manager assumes the responsibility for permanent state, when
	generating session IDs.

	The Manager must not be responsible for packet reception.  To
	prevent the Manager from becoming stuck because of a hostile
	Terminal, no portion of the protocol requires the Manager to retry
	transmission.  Part of this means that any valid packet which the
	Manager does receive *must* be acknowledged in some way, to prevent
	the Terminal from continuously resending packets.  The Terminal
	can keep the protocol running as it will always know when the
	Manager has received (at least one copy of) a packet.  On the
	Manager side, this means that any packet may be received
	more than once (if the response was lost) and duplicates must
	be ignored.
