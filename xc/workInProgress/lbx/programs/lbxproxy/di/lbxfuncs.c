/*
 * Copyright 1988-1993 Network Computing Devices, Inc.  All rights reserved.
 * An unpublished work.
 *
 * $NCDId: @(#)lbxfuncs.c,v 1.17 1994/02/03 00:41:49 lemke Exp $
 */

/*
 * top level LBX request & reply handling
 */

/*
 * notes on request short-circuiting
 *
 * X guarentees that any replies, events or errors generated by a
 * previous request will be sent before those of a later request.
 * this means that any requests that can be handled by the proxy
 * must have their reply sent after any previous events or errors.
 *
 * there are 3 possible stages implemented here:
 *
 * - fully correct protocol, where nothing can be out of order
 * - mostly correct protocol, where only errors can be out of order
 * - poor protocol, where events & errors can be out of order
 *
 * for most applications, poor is 'good enough', because they don't
 * depend on events coming in order, and instead let Xlib do
 * the work.
 *
 * depending on the type of protocol being used, the cache_safe
 * flag in the ClientRec will be set appropriately, and if TRUE,
 * the proxy is cleared to short-circuit a request.
 *
 * for full correct protocol, the flag is set if the previous request
 * was a round trip and the reply has come back.
 *
 * for a mostly correct protocol, the flag is set for the above
 * case, and for requests that can generate only errors (mostly
 * graphics)
 *
 * for a 'good enough' protocol, the flag is always on, and we let
 * the client sort things out.
 *
 * (note than in no case do we allow replies to come out of order.)
 *
 *
 * Note on Xlib's handling of sequences:
 *
 * Xlib usually waits for the reply to sync request before
 * issuing another -- its archetecture depends on it.  However,
 * this is not required.  Xlib itself misses this in at least one
 * case (XGetWindowAttributes, which uses both the GetWindowAttributes
 * and GetGeometry requests).
 *
 * The upshot is that the proxy has to be able to handle seeing
 * another request before it receives an expected reply.
 *
 * this means we can't assume a single pending reply, but many.
 * currently these get tacked onto a list.
 */


/* short-circuiting protocol */

/* #define	PROTOCOL_RAW		/* pure Xremote */
/* #define	PROTOCOL_SLOW		/* no caching at all */
/* #define	PROTOCOL_FULL		/* best w/ accuracy */
/* #define	PROTOCOL_MOST		/* cheat on errors */
#define	PROTOCOL_POOR		/* cheat on errors & events */

#undef	DEBUG

#undef	TRACE

/* nostacking turns on code that assumes Xlib waits for replies before
 * issuing requests -- break XGetWindowAttributes(), perhaps others
 */
#undef nostacking

/* possible states of request handlers.  some requests are short-circuited
 * (yanked), some are replaced with LBX requests, and some are let through
 * unchanged
 */
#define	REQ_NOCHANGE	0	/* pass through untouched -- lbx sends data */
#define	REQ_YANK	1	/* completely remove from stream */
#define	REQ_REPLACE	2	/* replace with new encoding */
#define	REQ_PASSTHROUGH	3	/* pass thorugh untouched, other sends data */

/*
 * how far we can let the server's sequence number slide before
 * bringing it up to date
 *
 * NOTE -- command only supports a char's worth of data
 */
#define	MAX_SEQUENCE_LOST	255

/*
 * size of motion event queue
 *
 * this specifies the maximum number of motion events that the server
 * can spew out at once.  the proxy will send it NUM_MOTION_EVENTS
 * AllowMotion requests at startup, and then send a new one each time it
 * processes a Motion event.  this will prevent the wire from being
 * swamped by MotionNotify.
 */

/* XXX this should be a calculation based on the wire latency */

#define	NUM_MOTION_EVENTS	8

#include	<stdio.h>
#define NEED_REPLIES
#define NEED_EVENTS
#include	<X11/X.h>	/* for KeymapNotify */
#include	<X11/Xproto.h>
#include	"assert.h"
#include	"lbxdata.h"
#include	"atomcache.h"
#include	"util.h"
#include	"tags.h"
#include	"colormap.h"
#include	"cmapst.h"
#include	"lbx.h"		/* gets dixstruct.h */
#include	"resource.h"
#include	"wire.h"
#define _XLBX_SERVER_
#include	"lbxstr.h"	/* gets dixstruct.h */

#define	LBX_STATS		/* stats gathering on short-circuiting & tags */

#ifdef LBX_STATS
static int  intern_good,
            intern_miss;
static int  getatom_good,
            getatom_miss;
static int  luc_good,
            luc_miss;
static int  ac_good,
            ac_miss;
static int  anc_good,
            anc_miss;

static int  getmodmap_tag,	/* tag only */
            getmodmap_full;
static int  getkeymap_tag,	/* tag only */
            getkeymap_full;


static int  missed_tag;		/* QueryTag required */

#endif				/* LBX_STATS */

static int  pad[4] = {0, 3, 2, 1};

static void finish_modmap_reply();
static void finish_keymap_reply();

#define reply_length(cp,rep) ((rep)->type==X_Reply ? \
        32 + (HostUnswapLong((cp),(rep)->length) << 2) \
	: 32)

#define	server_resource(client, xid)	(CLIENT_ID(xid) == 0)


/* XXX
 *
 * if preformance becomes an issue, the reply stuff can be reworked
 * to use a quicker allocation strategy.  we're at least guarenteed
 * that they'll come back in the order requested.
 */
ReplyStuffPtr
new_reply(client)
    ClientPtr   client;
{
    ReplyStuffPtr new,
                end;

    new = (ReplyStuffPtr) xalloc(sizeof(ReplyStuffRec));
    if (!new)
	return new;
    bzero((char *) new, sizeof(ReplyStuffRec));
    new->next = (ReplyStuffPtr) 0;
    end = LBXReplyList(client);
    if (!end) {
	LBXReplyList(client) = new;
    } else {
	while (end) {
	    if (!end->next) {
		end->next = new;
		break;
	    }
	    end = end->next;
	}
    }
    return new;
}

void
remove_reply(client)
    ClientPtr   client;
{
    ReplyStuffPtr old;

    old = LBXReplyList(client);
    assert(old);
    LBXReplyList(client) = old->next;
    xfree(old);
}

static      ReplyStuffPtr
get_reply(client)
    ClientPtr   client;
{
    assert(LBXReplyList(client));
    return LBXReplyList(client);
}

static int
num_replies(client)
    ClientPtr   client;
{
    int         num = 0;
    ReplyStuffPtr t;

    assert(LBXReplyList(client));
    t = LBXReplyList(client);
    while (t) {
	num++;
	t = t->next;
    }
    return num;
}

static void
bump_sequence(client)
    ClientPtr   client;
{
    DBG(DBG_CLIENT, (stderr, "bumping client %d sequence by %d to %d\n",
	 client->index, LBXSequenceLost(client), LBXSequenceNumber(client)));
    ModifySequence(client, LBXSequenceLost(client));
    LBXSequenceLost(client) = 0;
}

WriteToClientPad(client, len, data)
    ClientPtr   client;
    char       *data;
    int         len;
{
    char        pad[3];
    int         ret;

    WriteToClient(client, len, data);

/*
XXX -- OS layer pads for us.  this may be a mess later...
    len = (((len + 3) >> 2) << 2) - len;
    WriteToClient(client, len, pad);
*/
}

/* XXX this is quite gross -- need a better way... */
static int
send_query_tag(client, qtp)
    ClientPtr   client;
    QueryTagPtr	qtp;
{
    ReplyStuffPtr nr;

    nr = new_reply(client);
    if (nr) {
	nr->sequenceNumber = LBXSequenceNumber(client);
	nr->request = X_LbxQueryTag;
	nr->lbx_req = TRUE;
	nr->request_info.lbxquerytag.info = *qtp;

	SendQueryTag(client, qtp->tag);
    }

#ifdef LBX_STATS
    missed_tag++;
#endif
}

static int
get_query_tag_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xLbxQueryTagReply *rep;
    ReplyStuffPtr nr;
    pointer     tdata;
    int         len;
    QueryTagPtr	qtp;

    nr = get_reply(client);

    rep = (xLbxQueryTagReply *) data;
    tdata = (pointer) &rep[1];
    len = rep->length << 2;

    qtp = &(nr->request_info.lbxquerytag.info);

    TagStoreData(global_cache, qtp->tag, len, qtp->tagtype, tdata);

    /* and now finish off request */
    /* XXX ever have a case where there isn't one to finish? */
    switch (qtp->tagtype) {
    case LbxTagTypeModmap:
	finish_modmap_reply(client, rep->sequenceNumber,
			    qtp->typedata.modmap.keyspermod, tdata);
	break;
    case LbxTagTypeKeymap:
	finish_keymap_reply(client, rep->sequenceNumber,
			    qtp->typedata.keymap.keyspercode,
			    qtp->typedata.keymap.first,
			    qtp->typedata.keymap.count,
			    tdata);
	break;
    default:
	assert(0);
    }

    return TRUE;
}

static int
intern_atom_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xInternAtomReq *req;
    char       *s;
    Atom        atom,
                a;
    int         len;
    xInternAtomReply reply;
    ReplyStuffPtr nr;

    req = (xInternAtomReq *) data;

    if (req->nbytes > MAX_ATOM_LENGTH)
	return REQ_NOCHANGE;

    len = req->nbytes + sizeof(xInternAtomReq);

    s = data + sizeof(xInternAtomReq);

    atom = MakeAtom(s, req->nbytes, &a, FALSE);
    if (atom != None) {
	/* found preset atom */
	if (LBXCacheSafe(client)) {
	    reply.type = X_Reply;
	    reply.length = 0;
	    reply.sequenceNumber = LBXSequenceNumber(client);
	    reply.atom = atom;
	    WriteToClient(client, sizeof(xInternAtomReply), &reply);

#ifdef LBX_STATS
	    intern_good++;
#endif

	    return REQ_YANK;
	}
    } else if (req->nbytes < MAX_ATOM_LENGTH) {
	nr = new_reply(client);
	if (nr) {
	    strncpy(nr->request_info.lbxatom.str, s, req->nbytes);
	    nr->request_info.lbxatom.len = req->nbytes;
	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = X_InternAtom;
	}
    }

#ifdef LBX_STATS
    intern_miss++;
#endif

    return REQ_NOCHANGE;
}

static Bool
intern_atom_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    Atom        atom;
    char       *str;
    xInternAtomReply *reply;
    int         len;
    ReplyStuffPtr nr;

    reply = (xInternAtomReply *) data;

    atom = reply->atom;
    nr = get_reply(client);
    str = nr->request_info.lbxatom.str;
    len = nr->request_info.lbxatom.len;

    if (atom != None) {
	/* make sure it gets stuffed in the DB */
	(void) MakeAtom(str, len, atom, TRUE);
    }
    return TRUE;
}

static int
get_atom_name_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xResourceReq *req;
    char       *str;
    xGetAtomNameReply reply;
    int         len;
    ReplyStuffPtr nr;

    req = (xResourceReq *) data;

    str = NameForAtom(req->id);

    if (str) {
	/* found the value */
	if (LBXCacheSafe(client)) {

	    len = strlen(str);
	    reply.type = X_Reply;
	    reply.length = (len + 3) >> 2;
	    reply.sequenceNumber = LBXSequenceNumber(client);
	    reply.nameLength = len;
	    WriteToClient(client, sizeof(xGetAtomNameReply), &reply);
	    WriteToClientPad(client, len, str);

#ifdef LBX_STATS
	    getatom_good++;
#endif

	    return REQ_YANK;
	}
    } else {
	nr = new_reply(client);
	if (nr) {
	    nr->request_info.lbxatom.atom = req->id;
	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = X_GetAtomName;
	}
    }

#ifdef LBX_STATS
    getatom_miss++;
#endif

    return REQ_NOCHANGE;
}

static Bool
get_atom_name_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    Atom        atom;
    char       *s;
    xGetAtomNameReply *reply;
    int         len;
    ReplyStuffPtr nr;

    reply = (xGetAtomNameReply *) data;

    if ((reply->length << 2) > MAX_ATOM_LENGTH)
	return;

    len = (reply->length << 2) + sizeof(xGetAtomNameReply);

    s = data + sizeof(xGetAtomNameReply);

    len -= sizeof(xGetAtomNameReply);
    nr = get_reply(client);
    atom = nr->request_info.lbxatom.atom;

    /* make sure it gets stuffed in the DB */
    (void) MakeAtom(s, len, atom, TRUE);
    return TRUE;
}

static int
lookup_color_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xLookupColorReq *req;
    xLookupColorReply reply;
    ReplyStuffPtr nr;
    RGBEntryPtr rgbe;
    int         len;

    req = (xLookupColorReq *) data;

    len = req->nbytes;
    if (len > MAX_COLORNAME_LENGTH)
	return REQ_NOCHANGE;

/* XXX for now, ignore attempts to anything but default colormaps */
    if (!server_resource(client, req->cmap))
	return REQ_NOCHANGE;

    rgbe = FindColorName((char *) &req[1], len, req->cmap);

    if (rgbe) {
	/* found the value */
	if (LBXCacheSafe(client)) {
	    reply.type = X_Reply;
	    reply.length = 0;
	    reply.sequenceNumber = LBXSequenceNumber(client);

	    reply.exactRed = rgbe->xred;
	    reply.exactBlue = rgbe->xblue;
	    reply.exactGreen = rgbe->xgreen;

	    reply.screenRed = rgbe->vred;
	    reply.screenBlue = rgbe->vblue;
	    reply.screenGreen = rgbe->vgreen;

	    WriteToClient(client, sizeof(xLookupColorReply), &reply);

#ifdef LBX_STATS
	    luc_good++;
#endif

	    return REQ_YANK;
	}
    } else {
	nr = new_reply(client);
	if (nr) {
	    strncpy(nr->request_info.lbxlookupcolor.name,
		    (char *) &req[1], len);
	    nr->request_info.lbxlookupcolor.namelen = len;
	    nr->request_info.lbxlookupcolor.cmap = req->cmap;
	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = X_LookupColor;
	}
    }

#ifdef LBX_STATS
    luc_miss++;
#endif

    return REQ_NOCHANGE;
}

static Bool
lookup_color_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xLookupColorReply *reply;
    int         len;
    ReplyStuffPtr nr;
    RGBEntryRec rgbe;

    reply = (xLookupColorReply *) data;

    nr = get_reply(client);

    rgbe.xred = reply->exactRed;
    rgbe.xblue = reply->exactBlue;
    rgbe.xgreen = reply->exactGreen;
    rgbe.vred = reply->screenRed;
    rgbe.vblue = reply->screenBlue;
    rgbe.vgreen = reply->screenGreen;

    rgbe.cmap = nr->request_info.lbxlookupcolor.cmap;

    AddColorName(nr->request_info.lbxlookupcolor.name,
		 nr->request_info.lbxlookupcolor.namelen,
		 &rgbe);
    return TRUE;
}

static int
alloc_color_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xAllocColorReq *req;
    xAllocColorReply reply;
    Pixel       pix;
    Entry      *pent;
    ReplyStuffPtr nr;

    req = (xAllocColorReq *) data;

    FindPixel(client, req->cmap, (int) req->red, (int) req->green,
	      (int) req->blue, &pent);
    if (pent) {
	/* always inc the pixel, so our refcounts match the server's */
	IncrementPixel(client, req->cmap, pent);

	/* found the value */
	if (LBXCacheSafe(client)) {

	    /* must tell server to bump refcnt */
	    SendIncrementPixel(client, req->cmap, pent->pixel);

	    reply.type = X_Reply;
	    reply.length = 0;
	    reply.sequenceNumber = LBXSequenceNumber(client);

	    reply.red = pent->rep_red;
	    reply.green = pent->rep_green;
	    reply.blue = pent->rep_blue;
	    reply.pixel = pent->pixel;

	    WriteToClient(client, sizeof(xAllocColorReply), &reply);

#ifdef LBX_STATS
	    ac_good++;
#endif

	    return REQ_REPLACE;	/* packet sent anyways */
	}
    } else {
	nr = new_reply(client);
	if (nr) {
	    nr->request_info.lbxalloccolor.cmap = req->cmap;
	    nr->request_info.lbxalloccolor.red = req->red;
	    nr->request_info.lbxalloccolor.green = req->green;
	    nr->request_info.lbxalloccolor.blue = req->blue;
	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = X_AllocColor;
	}
    }

#ifdef LBX_STATS
    ac_miss++;
#endif

    return REQ_NOCHANGE;
}

static Bool
alloc_color_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xAllocColorReply *reply;
    ReplyStuffPtr nr;

    reply = (xAllocColorReply *) data;

    nr = get_reply(client);

    /*
     * save requested color, since they're more likely to ask for the same
     * thing again.  also have to store reply RGB.
     */
    StorePixel(client, nr->request_info.lbxalloccolor.cmap,
	       nr->request_info.lbxalloccolor.red,
	       nr->request_info.lbxalloccolor.green,
	       nr->request_info.lbxalloccolor.blue,
	       (int) reply->red, (int) reply->green, (int) reply->blue,
	       reply->pixel);
    return TRUE;
}

static int
alloc_named_color_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xAllocNamedColorReq *req;
    xAllocNamedColorReply reply;
    Pixel       pix;
    Entry      *pent;
    RGBEntryPtr rgbe;
    ReplyStuffPtr nr;

    req = (xAllocNamedColorReq *) data;

    if (req->nbytes > MAX_COLORNAME_LENGTH)
	return REQ_NOCHANGE;

    FindNamedPixel(client, req->cmap, (char *) &req[1], req->nbytes, &pent);
    rgbe = FindColorName((char *) &req[1], req->nbytes, req->cmap);

    /* better get both if we got one... */
    if (pent && rgbe) {
	/* always inc the pixel, so our refcounts match the server's */
	IncrementPixel(client, req->cmap, pent);
	/* found the value */
	if (LBXCacheSafe(client)) {

	    /* must tell server to bump refcnt */
	    SendIncrementPixel(client, req->cmap, pent->pixel);

	    reply.type = X_Reply;
	    reply.length = 0;
	    reply.sequenceNumber = LBXSequenceNumber(client);

	    reply.screenRed = pent->rep_red;
	    reply.screenGreen = pent->rep_green;
	    reply.screenBlue = pent->rep_blue;
	    reply.exactRed = rgbe->xred;
	    reply.exactGreen = rgbe->xgreen;
	    reply.exactBlue = rgbe->xblue;

	    reply.pixel = pent->pixel;

	    WriteToClient(client, sizeof(xAllocNamedColorReply), &reply);

#ifdef LBX_STATS
	    anc_good++;
#endif

	    return REQ_REPLACE;	/* packet sent anyways */
	}
    } else {
	nr = new_reply(client);
	if (nr) {
	    nr->request_info.lbxallocnamedcolor.cmap = req->cmap;
	    strncpy(nr->request_info.lbxallocnamedcolor.name, (char *) &req[1],
		    req->nbytes);
	    nr->request_info.lbxallocnamedcolor.namelen = req->nbytes;

	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = X_AllocNamedColor;
	}
    }

#ifdef LBX_STATS
    anc_miss++;
#endif

    return REQ_NOCHANGE;
}

static Bool
alloc_named_color_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xAllocNamedColorReply *reply;
    ReplyStuffPtr nr;

    reply = (xAllocNamedColorReply *) data;

    nr = get_reply(client);

    StoreNamedPixel(client,
		    nr->request_info.lbxallocnamedcolor.cmap,
		    nr->request_info.lbxallocnamedcolor.name,
		    nr->request_info.lbxallocnamedcolor.namelen,
      (int) reply->exactRed, (int) reply->exactGreen, (int) reply->exactBlue,
    (int) reply->screenRed, (int) reply->screenGreen, (int) reply->screenBlue,
		    reply->pixel);
    return TRUE;
}

static int
free_colormap_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xResourceReq *req;

    req = (xResourceReq *) data;
    FreeColormap(req->id);

    return REQ_NOCHANGE;
}

static int
create_colormap_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xCreateColormapReq *req;

    req = (xCreateColormapReq *) data;
    if (!req->alloc)		/* AllocAll are read/write, so ignore */
	CreateColormap(client, req->mid, req->window, req->visual);

    return REQ_NOCHANGE;
}

static int
copy_colormap_and_free_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xCopyColormapAndFreeReq *req;

    req = (xCopyColormapAndFreeReq *) data;
    CopyAndFreeColormap(client, req->mid, req->srcCmap);

    return REQ_NOCHANGE;
}

static int
free_colors_req(client, data)
    ClientPtr   client;
    char       *data;
{
    xFreeColorsReq *req;
    int         num;
    Pixel      *pixels;

    req = (xFreeColorsReq *) data;

    num = ((req->length << 2) - sizeof(xFreeColorsReq)) >> 2;
    pixels = (Pixel *) &req[1];

    FreePixels(client, req->cmap, num, pixels);
    return REQ_NOCHANGE;
}

static int
get_mod_map_req(client, data)
    ClientPtr   client;
    char       *data;
{
    ReplyStuffPtr nr;

    nr = new_reply(client);
    if (nr) {
	nr->sequenceNumber = LBXSequenceNumber(client);
	nr->request = X_LbxGetModifierMapping;
	nr->lbx_req = TRUE;

	SendGetModifierMapping(client);

	return REQ_REPLACE;
    } else
	return REQ_NOCHANGE;
}

static void
finish_modmap_reply(client, seqnum, kpm, data)
    ClientPtr   client;
    int         seqnum;
    int         kpm;
    pointer     data;
{
    xGetModifierMappingReply reply;
    int         len = kpm << 3;

    reply.type = X_Reply;
    reply.numKeyPerModifier = kpm;
    reply.sequenceNumber = seqnum;
    reply.length = len >> 2;

    WriteToClient(client, sizeof(xGetModifierMappingReply), &reply);
    WriteToClientPad(client, len, data);
}

static Bool
get_mod_map_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xGetModifierMappingReply reply;
    xLbxGetModifierMappingReply *rep;
    int         len;
    pointer     tag_data;
    ReplyStuffPtr nr;
    QueryTagRec qt;

    rep = (xLbxGetModifierMappingReply *) data;

    nr = get_reply(client);

    len = rep->keyspermod << 3;
    if (rep->tag) {
	if (rep->length) {	/* first time, set tag */

#ifdef LBX_STATS
	    getmodmap_full++;
#endif

	    tag_data = (pointer) &rep[1];
	    if (!TagStoreData(global_cache, rep->tag, len,
			      LbxTagTypeModmap, tag_data)) {
		/* tell server we lost it */
		SendInvalidateTag(client, rep->tag);
	    }
	} else {

#ifdef LBX_STATS
	    getmodmap_tag++;
#endif

	    tag_data = TagGetData(global_cache, rep->tag);
	    if (!tag_data) {
                qt.tag = rep->tag;
                qt.tagtype = LbxTagTypeModmap;
                qt.typedata.modmap.keyspermod = rep->keyspermod;
		/* lost data -- ask again for tag value */
		send_query_tag(client, &qt);

		/* XXX what is the right way to stack Queries? */
		return TRUE;
	    }
	}
    } else {

#ifdef LBX_STATS
	getmodmap_full++;
#endif

	/* server didn't send us a tag for some reason -- just pass on data */
	tag_data = (pointer) &rep[1];
    }

    finish_modmap_reply(client, rep->sequenceNumber, (int) rep->keyspermod,
			tag_data);

    return TRUE;
}

static int
get_key_map_req(client, data)
    ClientPtr   client;
    char       *data;
{
    ReplyStuffPtr nr;
    xGetKeyboardMappingReq *req;

    req = (xGetKeyboardMappingReq *) data;
    nr = new_reply(client);
    if (nr) {
	nr->sequenceNumber = LBXSequenceNumber(client);
	nr->request = X_LbxGetKeyboardMapping;
	nr->lbx_req = TRUE;
	nr->request_info.lbxgetkeymap.count = req->count;
	nr->request_info.lbxgetkeymap.first = req->firstKeyCode;

	SendGetKeyboardMapping(client);

	return REQ_REPLACE;
    } else
	return REQ_NOCHANGE;
}

/*
 * always ask for the whole map from server, and send requested subset to
 * client
 */
static void
finish_keymap_reply(client, seqnum, kpk, first, count, data)
    ClientPtr   client;
    int         seqnum;
    int         kpk;
    int         first;
    int         count;
    char        *data;
{
    xGetKeyboardMappingReply reply;
    int         len = (kpk * count) << 2;

    reply.type = X_Reply;
    reply.keySymsPerKeyCode = kpk;
    reply.sequenceNumber = seqnum;
    reply.length = len >> 2;

    WriteToClient(client, sizeof(xGetKeyboardMappingReply), &reply);
    data += kpk * (first - LBXMinKeyCode(client));
    WriteToClientPad(client, len, data);
}


static Bool
get_key_map_reply(client, data)
    ClientPtr   client;
    char       *data;
{
    xGetKeyboardMappingReply reply;
    xLbxGetKeyboardMappingReply *rep;
    int         len;
    pointer     tag_data;
    ReplyStuffPtr nr;
    QueryTagRec	qt;

    rep = (xLbxGetKeyboardMappingReply *) data;

    nr = get_reply(client);

    if (rep->tag) {
	if (rep->length) {	/* first time, set tag */

#ifdef LBX_STATS
	    getkeymap_full++;
#endif

	    tag_data = (pointer) &rep[1];
	    len = rep->keysperkeycode *
		(LBXMaxKeyCode(client) - LBXMinKeyCode(client) + 1) * 4;
	    if (!TagStoreData(global_cache, rep->tag, len,
			      LbxTagTypeKeymap, tag_data)) {
		/* tell server we lost it */
		SendInvalidateTag(client, rep->tag);
	    }
	} else {

#ifdef LBX_STATS
	    getkeymap_tag++;
#endif

	    tag_data = TagGetData(global_cache, rep->tag);
	    if (!tag_data) {
		/* lost data -- ask again for tag value */

                qt.tag = rep->tag;
                qt.tagtype = LbxTagTypeKeymap;
                qt.typedata.keymap.keyspercode = rep->keysperkeycode;
                qt.typedata.keymap.count = nr->request_info.lbxgetkeymap.count;
                qt.typedata.keymap.first = nr->request_info.lbxgetkeymap.first;
		send_query_tag(client, &qt);

		/* XXX what is the right way to stack Queries? */
		return TRUE;
	    }
	}
    } else {

#ifdef LBX_STATS
	getkeymap_full++;
#endif

	/* server didn't send us a tag for some reason -- just pass on data */
	tag_data = (pointer) &rep[1];
    }

    finish_keymap_reply(client, rep->sequenceNumber, (int) rep->keysperkeycode,
			nr->request_info.lbxgetkeymap.first,
			nr->request_info.lbxgetkeymap.count,
			tag_data);

    return TRUE;
}


/*
 * Routines for re-encoding line, rectangle and arc requests
 */

#define REENCODE_SHORT(val, out) \
    if ((val) >= (short)0x0800 || (val) < (short)0xf800) \
	return 0; \
    if ((val) <= -113 || (val) >= 128) \
	*(out)++ = 0x80 | (((val) >> 8) & 0x0f); \
    *(out)++ = (val) & 0xff;

#define REENCODE_USHORT(val, out) \
    if ((unsigned short)(val) >= 0x1000) \
	return 0; \
    if ((val) >= 240) \
	*(out)++ = 0xf0 | ((val) >> 8); \
    *(out)++ = (val) & 0xff;

#define REENCODE_ANGLE(val, out) \
    if ((val) < ((-360) << 6) || (val) > (360 << 6)) \
	return 0; \
    if (((val) & 0x007f) == 0) { \
	short angle = (val) >> 7; \
	if (angle % 45) { \
	    *(out)++ = (val) >> 8; \
	    *(out)++ = (val) & 0xff; \
	} \
	else \
	    *(out)++ = 0x80 | ((angle / 45) + 4); \
    }

static int
reencode_poly(client, lbxreq, reencode_rtn)
    ClientPtr   client;
    CARD8       lbxreq;
    int         (*reencode_rtn) ();
{
    REQUEST(xPolyPointReq);
    XServerPtr  server = client->server;
    int         len = stuff->length << 2;
    xLbxPolyPointReq *newreq = NULL;
    int         bytes;

    /* If it's delta compressible, don't try to reencode */
    if (DELTA_CACHEABLE(&server->outdeltas, len) ||
	    (newreq = (xLbxPolyPointReq *) xalloc(len)) == NULL ||
	    (bytes = (*reencode_rtn) (client, (short *) &stuff[1],
				      (char *) newreq + sz_xLbxPolyPointReq,
				      (len - sz_xPolyPointReq) >> 2)) == 0) {
	if (newreq)
	    xfree(newreq);
	return ProcStandardRequest(client);
    }
    FinishLBXRequest(client, REQ_PASSTHROUGH);

    newreq->reqType = server->lbxReq;
    newreq->lbxReqType = lbxreq;
    newreq->drawable = stuff->drawable;
    newreq->gc = stuff->gc;
    len = sz_xLbxPolyPointReq + bytes;
    newreq->padBytes = pad[len % 4];
    len += newreq->padBytes;
    newreq->length = len >> 2;
    WriteToServer(client, len, (char *) newreq);
    xfree(newreq);
    return Success;
}

static int
reencode_points_origin(client, in, out, count)
    ClientPtr   client;
    register short *in;
    register char *out;
    int         count;
{
    register short diff;
    int         i;
    short       last_x = 0;
    short       last_y = 0;
    char       *start_out = out;

    for (i = 0; i < count; i++, in += 2) {
	diff = in[0] - last_x;
	last_x = in[0];
	REENCODE_SHORT(diff, out);
	diff = in[1] - last_y;
	last_y = in[1];
	REENCODE_SHORT(diff, out);
    }
    return out - start_out;
}

static int
reencode_points_previous(client, in, out, count)
    ClientPtr   client;
    register short *in;
    register char *out;
    int         count;
{
    register short coord;
    register short diff;
    int         i;
    char       *start_out = out;

    for (i = 0; i < count; i++, in += 2) {
	REENCODE_SHORT(in[0], out);
	REENCODE_SHORT(in[1], out);
    }
    return out - start_out;
}

static int
reencode_segment(client, in, out, count)
    ClientPtr   client;
    register short *in;
    register char *out;
    int         count;
{
    register short diff;
    int         i;
    short       last_x = 0;
    short       last_y = 0;
    char       *start_out = out;

    count >>= 1;
    for (i = 0; i < count; i++, in += 4) {
	/* reencode (x1, y1) */
	diff = in[0] - last_x;
	last_x = in[0];
	REENCODE_SHORT(diff, out);
	diff = in[1] - last_y;
	last_y = in[1];
	REENCODE_SHORT(diff, out);

	/* reencode (x2, y2) */
	diff = in[2] - last_x;
	REENCODE_SHORT(diff, out);
	diff = in[3] - last_y;
	REENCODE_SHORT(diff, out);
    }
    return out - start_out;
}

static int
reencode_rectangle(client, in, out, count)
    ClientPtr   client;
    register short *in;
    register char *out;
    int         count;
{
    register short diff;
    int         i;
    short       last_x = 0;
    short       last_y = 0;
    char       *start_out = out;

    count >>= 1;
    for (i = 0; i < count; i++, in += 4) {
	/* reencode (x, y) origin */
	diff = in[0] - last_x;
	last_x = in[0];
	REENCODE_SHORT(diff, out);
	diff = in[1] - last_y;
	last_y = in[1];
	REENCODE_SHORT(diff, out);

	/* reencode (width, height) */
	REENCODE_USHORT(in[2], out);
	REENCODE_USHORT(in[3], out);
    }
    return out - start_out;
}

static int
reencode_arc(client, in, out, count)
    ClientPtr   client;
    register short *in;
    register char *out;
    int         count;
{
    register short diff;
    int         i;
    short       last_x = 0;
    short       last_y = 0;
    char       *start_out = out;

    count = count / 3;
    for (i = 0; i < count; i++, in += 6) {
	/* reencode (x, y) origin */
	diff = in[0] - last_x;
	last_x = in[0];
	REENCODE_SHORT(diff, out);
	diff = in[1] - last_y;
	last_y = in[1];
	REENCODE_SHORT(diff, out);

	/* reencode (width, height) */
	REENCODE_USHORT(in[2], out);
	REENCODE_USHORT(in[3], out);

	/* reencode (angle1, angle2) */
	REENCODE_ANGLE(in[4], out);
	REENCODE_ANGLE(in[5], out);
    }
    return out - start_out;
}


int
ProcLBXInternAtom(client)
    ClientPtr   client;
{
    int         yank;

    yank = intern_atom_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXGetAtomName(client)
    ClientPtr   client;
{
    int         yank;

    yank = get_atom_name_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXCreateColormap(client)
    ClientPtr   client;
{
    int         yank;

    yank = create_colormap_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXAllocColor(client)
    ClientPtr   client;
{
    int         yank;

    yank = alloc_color_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXAllocNamedColor(client)
    ClientPtr   client;
{
    int         yank;

    yank = alloc_named_color_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXFreeColormap(client)
    ClientPtr   client;
{
    int         yank;

    yank = free_colormap_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXCopyColormapAndFree(client)
    ClientPtr   client;
{
    int         yank;

    yank = copy_colormap_and_free_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXFreeColors(client)
    ClientPtr   client;
{
    int         yank;

    yank = free_colors_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXLookupColor(client)
    ClientPtr   client;
{
    int         yank;

    yank = lookup_color_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXGetModifierMapping(client)
    ClientPtr   client;
{
    int         yank;

    yank = get_mod_map_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXGetKeyboardMapping(client)
    ClientPtr   client;
{
    int         yank;

    yank = get_key_map_req(client, client->requestBuffer);
    return FinishLBXRequest(client, yank);
}

int
ProcLBXPolyPoint(client)
    ClientPtr   client;
{
    REQUEST(xPolyPointReq);
    int         (*reencode_rtn) ();

    reencode_rtn = (stuff->coordMode) ? reencode_points_previous :
	reencode_points_origin;
    return reencode_poly(client, X_LbxPolyPoint, reencode_rtn);
}

int
ProcLBXPolyLine(client)
    ClientPtr   client;
{
    REQUEST(xPolyLineReq);
    int         (*reencode_rtn) ();

    reencode_rtn = (stuff->coordMode) ? reencode_points_previous :
	reencode_points_origin;
    return reencode_poly(client, X_LbxPolyLine, reencode_rtn);
}

int
ProcLBXPolySegment(client)
    ClientPtr   client;
{
    return reencode_poly(client, X_LbxPolySegment, reencode_segment);
}

int
ProcLBXPolyRectangle(client)
    ClientPtr   client;
{
    return reencode_poly(client, X_LbxPolyRectangle, reencode_rectangle);
}

int
ProcLBXPolyArc(client)
    ClientPtr   client;
{
    return reencode_poly(client, X_LbxPolyArc, reencode_arc);
}

int
ProcLBXFillPoly(client)
    ClientPtr   client;
{
    REQUEST(xFillPolyReq);
    XServerPtr  server = client->server;
    int         len = stuff->length << 2;
    xLbxFillPolyReq *newreq = NULL;
    int         bytes;
    int         (*reencode_rtn) ();

    reencode_rtn = (stuff->coordMode) ? reencode_points_previous :
	reencode_points_origin;

    /* If it's delta compressible, don't try to reencode */
    if (DELTA_CACHEABLE(&server->outdeltas, len) ||
	    (newreq = (xLbxFillPolyReq *) xalloc(len)) == NULL ||
	    (bytes = (*reencode_rtn) (client, (short *) &stuff[1],
				      (char *) newreq + sz_xLbxFillPolyReq,
				      (len - sz_xFillPolyReq) >> 2)) == 0) {
	if (newreq)
	    xfree(newreq);
	return ProcStandardRequest(client);
    }
    FinishLBXRequest(client, REQ_PASSTHROUGH);

    newreq->reqType = server->lbxReq;
    newreq->lbxReqType = X_LbxFillPoly;
    newreq->drawable = stuff->drawable;
    newreq->gc = stuff->gc;
    newreq->shape = stuff->shape;
    len = sz_xLbxPolyPointReq + bytes;
    newreq->padBytes = pad[len % 4];
    len += newreq->padBytes;
    newreq->length = len >> 2;
    WriteToServer(client, len, (char *) newreq);
    xfree(newreq);
    return Success;
}

int
ProcLBXPolyFillRectangle(client)
    ClientPtr   client;
{
    return reencode_poly(client, X_LbxPolyFillRectangle, reencode_rectangle);
}

int
ProcLBXPolyFillArc(client)
    ClientPtr   client;
{
    return reencode_poly(client, X_LbxPolyFillArc, reencode_arc);
}

int
MakeLBXReply(client)
    ClientPtr   client;
{
    ReplyStuffPtr nr;

    REQUEST(xReq);

    /* create the reply struct for requests we don't do anything with */
    if (generates_replies(stuff->reqType)) {
	nr = new_reply(client);
	if (nr) {
	    nr->sequenceNumber = LBXSequenceNumber(client);
	    nr->request = stuff->reqType;
	    nr->extension = (stuff->reqType > X_NoOperation) ? stuff->reqType : 0;
	}
    }
    return FinishLBXRequest(client, REQ_PASSTHROUGH);
}

int
FinishLBXRequest(client, yank)
    ClientPtr   client;
    int         yank;
{
    REQUEST(xReq);

#define	yankable(y)	(((y) == REQ_YANK) || ((y) == REQ_REPLACE))

#ifdef PROTOCOL_SLOW
    LBXCacheSafe(client) = FALSE;
#endif

#ifdef PROTOCOL_FULL
    if (!yankable(yank) && (generates_events(stuff->reqType) ||
			    generates_replies(stuff->reqType)
			    || generates_errors(stuff->reqType)))
	LBXCacheSafe(client) = FALSE;
    else
	LBXCacheSafe(client) = TRUE;
#endif

#ifdef PROTOCOL_MOST
    if (!yankable(yank)
     (generates_events(stuff->reqType) || generates_replies(stuff->reqType)))
	LBXCacheSafe(client) = FALSE;
    else
	LBXCacheSafe(client) = TRUE;
#endif

#ifdef PROTOCOL_POOR
    LBXCacheSafe(client) = TRUE;
#endif

    if (yank == REQ_YANK) {
	LBXSequenceLost(client)++;
	LBXYanked(client)++;
	LBXLastReply(client) = LBXSequenceNumber(client);
	DBG(DBG_CLIENT, (stderr, "short-circuited client %d req %d\n",
			 client->index, stuff->reqType));
    }
    /* make sure server's sequence number is accurate */
    if ((!yankable(yank) && LBXSequenceLost(client)) ||
	    (LBXSequenceLost(client) >= MAX_SEQUENCE_LOST)) {
	bump_sequence(client);
    }
    if (yank == REQ_NOCHANGE) {
	WriteReqToServer(client, stuff->length << 2, stuff);
    }
    return Success;
}

/*
 * NOTE
 *
#ifdef notyet
 * data coming in may not be on a word boundary, so it has to be
 * shuffled up
#endif
 *
 * returns TRUE if data (possibly modified) is to be sent on to client,
 * FALSE if data is replaced
 */
Bool
DoLBXReply(client, data, len)
    ClientPtr   client;
    char       *data;
    int         len;
{
    xGenericReply *reply;
    int         rlen;
    xError     *err;
    ReplyStuffPtr nr;
    Bool        remove_it = TRUE;
    Bool        ret = TRUE;

#ifdef PROTOCOL_RAW
    return;
#endif

    /* make sure data is on word boundary */

#ifdef notyet
    bcopy(data, temp_buffer, len);
    reply = (xGenericReply *) temp_buffer;
#else
    reply = (xGenericReply *) data;
#endif

    if (client->awaitingSetup) {/* snarf setup info */
	GetConnectionInfo(client, reply, len);
	return TRUE;
    }

#ifdef old
    rlen = reply_length(client, reply);

    if (len != rlen)
	fprintf(stderr, "HELP -- reply length not the same as buffer length\n");
#endif

#ifdef DEBUG
    if (reply->sequenceNumber < LBXLastReply(client))
	fprintf(stderr, "replies out of whack for client %d\n", client->index);
#endif

    if (reply->sequenceNumber > LBXSequenceNumber(client))
	fprintf(stderr, "BOGUS DATA\n");

    if (reply->type != X_Reply) {	/* event or error */

#ifdef TRACE
	fprintf(stderr, "got event/error %d (%d %d)\n",
		(reply->type & 0x7f), reply->sequenceNumber, client->XRemId);
#endif

	if ((reply->type & 0x7f) >= LASTEvent)
	    fprintf(stderr, "Extension event or BOGUS REPLY TYPE\n");

	/* clear out pending replies that resulted in errors */
	if (reply->type == X_Error) {
	    err = (xError *) reply;
	    nr = get_reply(client);
	    if (nr &&
		    (err->sequenceNumber == nr->sequenceNumber) &&
		    (err->majorCode == nr->request)) {
		remove_reply(client);
	    }
	}
	/* KeymapNotify has no sequence # */
	if ((reply->sequenceNumber < LBXLastReply(client)) &&
		reply->type != KeymapNotify) {
	    /*
	     * the server's sequence number is out-of-date. fix the
	     * event/error so its correct
	     */
	    err = (xError *) reply;

#ifdef DEBUG
	    fprintf(stderr, "rewriting error/event sequence number from %d to %d\n",
		    err->sequenceNumber, client->sequenceNumber);
#endif

	    err->sequenceNumber = LBXLastReply(client);

#ifdef notyet
	    /* move the changed value into the proper place */
	    bcopy(temp_buffer, data, len);
#endif
	}
	if (reply->type == MotionNotify) {
	    AllowMotion(client, 1);
	}
	return TRUE;
    }
    nr = get_reply(client);

    if (!nr)			/* what is this???? */
	return TRUE;

    /*
     * all unknown (extension) requests get a reply struct.  since we don't
     * know if there's really a reply for them or not, we can't clean them out
     * till we do get a reply.  at this point, we clear them out till we reach
     * either a safe reply struct, or an extension struct that has a matching
     * sequence number.
     */
    while (nr->extension && num_replies(client) > 1) {
	if (nr->sequenceNumber == reply->sequenceNumber)
	    break;
	remove_reply(client);
	nr = get_reply(client);
	assert(nr);
    }


#ifdef TRACE
    fprintf(stderr, "got reply supposedly for %d (%d %d)\n",
	    nr->request, reply->sequenceNumber, client->index);
#endif

    /* sequence number coming back should be the same as what's coming out */
    if (nr->sequenceNumber != reply->sequenceNumber)
	fprintf(stderr, "HELP -- reply for %d out-of-sync %d %d\n",
		nr->request,
		reply->sequenceNumber, nr->sequenceNumber);

#ifndef PROTOCOL_SLOW
    LBXCacheSafe(client) = TRUE;/* found matching reply, go for it */
#endif

    if (!nr->extension) {
	switch (nr->request) {
	case X_InternAtom:
	    remove_it = intern_atom_reply(client, reply);
	    break;
	case X_GetAtomName:
	    remove_it = get_atom_name_reply(client, reply);
	    break;
	case X_LookupColor:
	    remove_it = lookup_color_reply(client, reply);
	    break;
	case X_AllocColor:
	    remove_it = alloc_color_reply(client, reply);
	    break;
	case X_AllocNamedColor:
	    remove_it = alloc_named_color_reply(client, reply);
	    break;
	default:
	    break;
	}
    } else if (nr->lbx_req) {
        /* handle various extensions we know about */
	switch (nr->request) {
	case X_LbxGetModifierMapping:
	    remove_it = get_mod_map_reply(client, reply);
	    ret = FALSE;
	    break;
	case X_LbxGetKeyboardMapping:
	    remove_it = get_key_map_reply(client, reply);
	    ret = FALSE;
	    break;
	case X_LbxQueryTag:
	    remove_it = get_query_tag_reply(client, reply);
	    ret = FALSE;
	    break;
	default:
	    break;
	}
    } else {
    	/* XXX handle any other extensions we may know about */
    }
    if (remove_it)
	remove_reply(client);
    return ret;
}

#ifdef LBX_STATS
void
dump_stats()
{
    fprintf(stderr, "Short-circuit stats\n");
    fprintf(stderr, "InternAtom cache hits %d misses %d\n", intern_good, intern_miss);
    fprintf(stderr, "GetAtomName cache hits %d misses %d\n", getatom_good, getatom_miss);
    fprintf(stderr, "LookupColor cache hits %d misses %d\n", luc_good, luc_miss);
    fprintf(stderr, "AllocColor cache hits %d misses %d\n", ac_good, ac_miss);
    fprintf(stderr, "AllocNamedColor cache hits %d misses %d\n", anc_good, anc_miss);

    fprintf(stderr, "Tag stats\n");
    fprintf(stderr, "GetModifierMapping used tag %d, full data %d\n", getmodmap_tag, getmodmap_full);
    fprintf(stderr, "GetKeyboardMapping used tag %d, full data %d\n", getkeymap_tag, getkeymap_full);
    fprintf(stderr, "QueryTag called %d\n", missed_tag);
}

void
zero_stats()
{
    intern_good = intern_miss = 0;
    getatom_good = getatom_miss = 0;
    luc_good = luc_miss = 0;
    ac_good = ac_miss = 0;
    anc_good = anc_miss = 0;

    getmodmap_tag = 0;
    getmodmap_full = 0;
    getkeymap_tag = 0;
    getkeymap_full = 0;
    missed_tag = 0;
}

#endif

SendInitLBXPackets()
{
    AllowMotion(serverClient, NUM_MOTION_EVENTS);
}

GetConnectionInfo(client, reply, replylen)
    ClientPtr   client;
    char       *reply;
    int         replylen;
{
    xConnSetup *cs;
    xWindowRoot *root;
    xDepth     *depth;
    xVisualType *vis;
    char       *dp;
    int         i,
                j,
                k;
    static Bool first_time = TRUE;

    dp = reply;
    dp += sizeof(xConnSetupPrefix);
    cs = (xConnSetup *) dp;

    /* get more as needed */
    LBXMinKeyCode(client) = cs->minKeyCode;
    LBXMaxKeyCode(client) = cs->maxKeyCode;

    /* don't create the default stuff more than once */
    if (!first_time)
	return;

    dp += sizeof(xConnSetup);

    /* skip vendor string & pixmap formats */
    dp += cs->nbytesVendor + pad[cs->nbytesVendor & 3];
    dp += (cs->numFormats * sizeof(xPixmapFormat));

    /* process screens */
    root = (xWindowRoot *) dp;
    for (i = 0; i < cs->numRoots; i++) {
	dp += sizeof(xWindowRoot);
	for (j = 0; j < root->nDepths; j++) {
	    depth = (xDepth *) dp;
	    dp += sizeof(xDepth);
	    for (k = 0; k < depth->nVisuals; k++) {
		vis = (xVisualType *) dp;
		CreateVisual(depth->depth, vis);
		dp += (sizeof(xVisualType));
		vis = (xVisualType *) dp;
	    }
	}
	CreateColormap(serverClient, root->defaultColormap, root->windowId,
		       root->rootVisualID);
    }
    first_time = FALSE;
}

Bool
MakeLBXStuff(client)
    ClientPtr	client;
{
    LBXDataPtr  new;

    new = (LBXDataPtr) xalloc(sizeof(LBXDataRec));
    if (!new)
	return FALSE;
    bzero((char *) new, sizeof(LBXDataRec));
    client->screenPrivate[0] = (pointer) new;
    return TRUE;
}

void
FreeLBXStuff(client)
    ClientPtr	client;
{
    xfree(client->screenPrivate[0]);
}

void
LbxFreeTag(tag)
    XID         tag;
{
    TagFreeData(global_cache, tag, FALSE);
}

LbxCleanupSession()
{

#ifdef LBX_STATS
    dump_stats();
    zero_stats();
#endif
}
